### Eclipse Workspace Patch 1.0
#P luasql
Index: src/ls_firebird.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/ls_firebird.c,v
retrieving revision 1.12
diff -u -r1.12 ls_firebird.c
--- src/ls_firebird.c	27 Jun 2008 18:39:31 -0000	1.12
+++ src/ls_firebird.c	2 Aug 2008 00:31:37 -0000
@@ -33,7 +33,7 @@
 	short			dpb_length;		/* the used amount of the dpb */
 	isc_tr_handle	transaction;	/* the transaction handle */
 	int				lock;			/* lock count for open cursors */
-	int				autocommit;		/* should each statment be commited */
+	int				auto_commit;	/* should each statment be commited */
 } conn_data;
 
 typedef struct {
@@ -42,6 +42,7 @@
 	conn_data*		conn;			/* the DB connection this cursor is from */
 	isc_stmt_handle stmt;			/* the statment handle */
 	XSQLDA			*out_sqlda;		/* the cursor data array */
+	char			*modestring;
 } cur_data;
 
 /* How many fields to pre-alloc to the cursor */
@@ -302,6 +303,7 @@
 	cur.env = conn->env;
 	cur.conn = conn;
 	cur.stmt = NULL;
+    cur.modestring = "n";
 
 	cur.out_sqlda = (XSQLDA *)malloc(XSQLDA_LENGTH(CURSOR_PREALLOC));
 	cur.out_sqlda->version = SQLDA_VERSION1;
@@ -408,8 +410,8 @@
 		return return_db_error(L, conn->env->status_vector);
 	}
 
-	/* if autocommit is set and it's a non SELECT query, commit change */
-	if(conn->autocommit != 0 && stmt_type > 1) {
+	/* if auto_commit is set and it's a non SELECT query, commit change */
+	if(conn->auto_commit != 0 && stmt_type > 1) {
 		isc_commit_retaining(conn->env->status_vector, &conn->transaction);
 		if ( CHECK_DB_ERROR(conn->env->status_vector) ) {
 			free_cur(&cur);
@@ -498,11 +500,18 @@
 }
 
 /*
-** Sets the autocommit state of the connection
+** Sets the auto_commit state of the connection
 ** Lua Returns:
-**   autocommit state (0:off, 1:on)
+**   auto_commit state (0:off, 1:on)
 **   nil and error message on error.
 */
+static void conn_dosetautocommit(lua_State *L, conn_data *conn, int pos){
+	if(lua_toboolean(L, pos))
+		conn->auto_commit = 1;
+	else
+		conn->auto_commit = 0;
+}
+
 static int conn_setautocommit(lua_State *L) {
 	conn_data *conn = getconnection(L,1);
 
@@ -513,11 +522,7 @@
 		return 2;
 	}
 
-	if(lua_toboolean(L, 2))
-		conn->autocommit = 1;
-	else
-		conn->autocommit = 0;
-
+	conn_dosetautocommit(L, conn, 2);
 	lua_pushboolean(L, 1);
 	return 1;
 }
@@ -545,7 +550,7 @@
 		return 2;
 	}
 
-	if(conn->autocommit != 0)
+	if(conn->auto_commit != 0)
 		isc_commit_transaction(conn->env->status_vector, &conn->transaction);
 	else
 		isc_rollback_transaction(conn->env->status_vector, &conn->transaction);
@@ -574,7 +579,7 @@
 	conn_data *conn = (conn_data *)luaL_checkudata(L,1,LUASQL_CONNECTION_FIREBIRD);
 
 	if(conn->closed == 0) {
-		if(conn->autocommit != 0)
+		if(conn->auto_commit != 0)
 			isc_commit_transaction(conn->env->status_vector, &conn->transaction);
 		else
 			isc_rollback_transaction(conn->env->status_vector, &conn->transaction);
@@ -621,6 +626,72 @@
 }
 
 /*
+ * Sets the connection parameters
+ */
+static void conn_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		conn_data *conn = getconnection(L, 1);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					if( lua_isboolean( L, -1 ) )
+						conn_dosetautocommit(L, conn, -1);
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified connection parameters
+ */
+static int conn_get( lua_State *L ) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		conn_data *conn = getconnection(L, 1);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					lua_pushstring( L, LUASQL_AUTOCOMMIT );
+					lua_pushboolean( L, conn->auto_commit );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+				conn_data *conn = getconnection(L, 1);
+				lua_pushboolean( L, conn->auto_commit );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
 ** Pushes the indexed value onto the lua stack
 */
 static void push_column(lua_State *L, int i, cur_data *cur) {
@@ -721,7 +792,7 @@
 	ISC_STATUS fetch_stat;
 	int i;
 	cur_data *cur = getcursor(L,1);
-	const char *opts = luaL_optstring (L, 3, "n");
+    const char *opts = luasql_getfetchmodestring( L, cur->modestring );
 	int num = strchr(opts, 'n') != NULL;
 	int alpha = strchr(opts, 'a') != NULL;
 
@@ -927,6 +998,71 @@
 }
 
 /*
+ * Sets the cursor parameters
+ */
+static void cur_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		cur_data *cur = getcursor(L, 1);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					if( lua_isstring( L, -1 ) )
+						cur->modestring = lua_tostring( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified cursor parameters
+ */
+static int cur_get( lua_State *L ) {
+	if( lua_istable( L, 2 ) ) {
+		lua_newtable(L);
+		int rsp = lua_gettop(L);
+		cur_data *cur = getcursor(L, 1);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					lua_pushstring( L, LUASQL_MODESTRING );
+					lua_pushstring( L, cur->modestring );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+				cur_data *cur = getcursor(L, 1);
+				lua_pushstring( L, cur->modestring );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
 ** Creates an Environment and returns it.
 */
 static int create_environment (lua_State *L) {
@@ -962,9 +1098,38 @@
 	conn_data* res_conn;
 
 	env_data *env = (env_data *) getenvironment (L, 1);
-	const char *sourcename = luaL_checkstring (L, 2);
-	const char *username = luaL_optstring (L, 3, "");
-	const char *password = luaL_optstring (L, 4, "");
+	
+	char *sourcename;
+	char *username;
+	char *password;
+
+	if( lua_istable( L, 2 ) ) {
+		lua_pushstring( L, LUASQL_SOURCENAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			sourcename = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_USERNAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			username = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_PASSWORD );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			password = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+	} else {
+		sourcename = luaL_checkstring (L, 2);
+		username = luaL_optstring (L, 3, "");
+		password = luaL_optstring (L, 4, "");
+	}
 
 	/* check for an open enviroment */
 	if(env->closed != 0) {
@@ -977,7 +1142,7 @@
 	conn.db = 0L;
 	conn.transaction = 0L;
 	conn.lock = 0;
-	conn.autocommit = 0;
+	conn.auto_commit = 0;
 
 	/* Construct a database parameter buffer. */
 	dpb = conn.dpb_buffer;
@@ -1070,6 +1235,71 @@
 }
 
 /*
+ * Sets the environment parameters
+ */
+static void env_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		env_data *env = getenvironment(L, 1);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					if( lua_isnumber( L, -1 ) )
+						env->locktimeout = lua_tointeger( L, -1 );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+/*
+ * Retrieve the specified environment parameters
+ */
+static int env_get(lua_State *L) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		env_data *env = getenvironment(L, 1);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+					lua_pushinteger( L, env->locktimeout );
+					lua_settable( L, rsp );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+/*
+			if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+				env_data *env = getenvironment(L, 1);
+				lua_pushinteger( L, env->locktimeout );
+			} else  */
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
 ** Create metatables for each class of object.
 */
 static void create_metatables (lua_State *L) {
@@ -1077,6 +1307,8 @@
 		{"__gc", env_gc},
 		{"close", env_close},
 		{"connect", env_connect},
+	    {"get", env_get},
+	    {"set", env_set},
 		{NULL, NULL},
 	};
 	struct luaL_reg connection_methods[] = {
@@ -1087,6 +1319,8 @@
 		{"rollback", conn_rollback},
 		{"setautocommit", conn_setautocommit},
 		{"escape", conn_escape},
+	    {"get", conn_get},
+	    {"set", conn_set},
 		{NULL, NULL},
 	};
 	struct luaL_reg cursor_methods[] = {
@@ -1095,11 +1329,15 @@
 		{"fetch", cur_fetch},
 		{"getcoltypes", cur_coltypes},
 		{"getcolnames", cur_colnames},
+	    {"get", cur_get},
+	    {"set", cur_set},
 		{NULL, NULL},
 	};
+
 	luasql_createmeta (L, LUASQL_ENVIRONMENT_FIREBIRD, environment_methods);
 	luasql_createmeta (L, LUASQL_CONNECTION_FIREBIRD, connection_methods);
 	luasql_createmeta (L, LUASQL_CURSOR_FIREBIRD, cursor_methods);
+	lua_pop (L, 3);
 }
 
 /*
Index: src/ls_mysql.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/ls_mysql.c,v
retrieving revision 1.29
diff -u -r1.29 ls_mysql.c
--- src/ls_mysql.c	4 May 2008 02:46:17 -0000	1.29
+++ src/ls_mysql.c	2 Aug 2008 00:31:37 -0000
@@ -1,590 +1,846 @@
-/*
-** LuaSQL, MySQL driver
-** Authors:  Eduardo Quintao
-** See Copyright Notice in license.html
-** $Id: ls_mysql.c,v 1.29 2008/05/04 02:46:17 tomas Exp $
-*/
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-#ifdef WIN32
-#include <winsock2.h>
-#define NO_CLIENT_LONG_LONG
-#endif
-
-#include "mysql.h"
-
-#include "lua.h"
-#include "lauxlib.h"
-#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
-#include "compat-5.1.h"
-#endif
-
-
-#include "luasql.h"
-
-#define LUASQL_ENVIRONMENT_MYSQL "MySQL environment"
-#define LUASQL_CONNECTION_MYSQL "MySQL connection"
-#define LUASQL_CURSOR_MYSQL "MySQL cursor"
-
-/* For compat with old version 4.0 */
-#if (MYSQL_VERSION_ID < 40100) 
-#define MYSQL_TYPE_VAR_STRING   FIELD_TYPE_VAR_STRING 
-#define MYSQL_TYPE_STRING       FIELD_TYPE_STRING 
-#define MYSQL_TYPE_DECIMAL      FIELD_TYPE_DECIMAL 
-#define MYSQL_TYPE_SHORT        FIELD_TYPE_SHORT 
-#define MYSQL_TYPE_LONG         FIELD_TYPE_LONG 
-#define MYSQL_TYPE_FLOAT        FIELD_TYPE_FLOAT 
-#define MYSQL_TYPE_DOUBLE       FIELD_TYPE_DOUBLE 
-#define MYSQL_TYPE_LONGLONG     FIELD_TYPE_LONGLONG 
-#define MYSQL_TYPE_INT24        FIELD_TYPE_INT24 
-#define MYSQL_TYPE_YEAR         FIELD_TYPE_YEAR 
-#define MYSQL_TYPE_TINY         FIELD_TYPE_TINY 
-#define MYSQL_TYPE_TINY_BLOB    FIELD_TYPE_TINY_BLOB 
-#define MYSQL_TYPE_MEDIUM_BLOB  FIELD_TYPE_MEDIUM_BLOB 
-#define MYSQL_TYPE_LONG_BLOB    FIELD_TYPE_LONG_BLOB 
-#define MYSQL_TYPE_BLOB         FIELD_TYPE_BLOB 
-#define MYSQL_TYPE_DATE         FIELD_TYPE_DATE 
-#define MYSQL_TYPE_NEWDATE      FIELD_TYPE_NEWDATE 
-#define MYSQL_TYPE_DATETIME     FIELD_TYPE_DATETIME 
-#define MYSQL_TYPE_TIME         FIELD_TYPE_TIME 
-#define MYSQL_TYPE_TIMESTAMP    FIELD_TYPE_TIMESTAMP 
-#define MYSQL_TYPE_ENUM         FIELD_TYPE_ENUM 
-#define MYSQL_TYPE_SET          FIELD_TYPE_SET
-#define MYSQL_TYPE_NULL         FIELD_TYPE_NULL
-
-#define mysql_commit(_) ((void)_)
-#define mysql_rollback(_) ((void)_)
-#define mysql_autocommit(_,__) ((void)_)
-
-#endif
-
-typedef struct {
-	short      closed;
-} env_data;
-
-typedef struct {
-	short      closed;
-	int        env;                /* reference to environment */
-	MYSQL     *my_conn;
-} conn_data;
-
-typedef struct {
-	short      closed;
-	int        conn;               /* reference to connection */
-	int        numcols;            /* number of columns */
-	int        colnames, coltypes; /* reference to column information tables */
-	MYSQL_RES *my_res;
-} cur_data;
-
-LUASQL_API int luaopen_luasql_mysql (lua_State *L);
-
-
-/*
-** Generates a driver error plus the error message from the database
-** The generated error message is preceded by LUASQL_PREFIX string
-*/
-static int luasql_failmessage(lua_State *L, const char *err, const char *m) {
-    lua_pushnil(L);
-	lua_pushstring(L, LUASQL_PREFIX);
-	lua_pushstring(L, err);
-    lua_pushstring(L, m);
-	lua_concat(L, 3);
-    return 2;
-}
-
-
-/*
-** Check for valid environment.
-*/
-static env_data *getenvironment (lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_MYSQL);
-	luaL_argcheck (L, env != NULL, 1, "environment expected");
-	luaL_argcheck (L, !env->closed, 1, "environment is closed");
-	return env;
-}
-
-
-/*
-** Check for valid connection.
-*/
-static conn_data *getconnection (lua_State *L) {
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_MYSQL);
-	luaL_argcheck (L, conn != NULL, 1, "connection expected");
-	luaL_argcheck (L, !conn->closed, 1, "connection is closed");
-	return conn;
-}
-
-
-/*
-** Check for valid cursor.
-*/
-static cur_data *getcursor (lua_State *L) {
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_MYSQL);
-	luaL_argcheck (L, cur != NULL, 1, "cursor expected");
-	luaL_argcheck (L, !cur->closed, 1, "cursor is closed");
-	return cur;
-}
-
-
-/*
-** Push the value of #i field of #tuple row.
-*/
-static void pushvalue (lua_State *L, void *row, long int len) {
-	if (row == NULL)
-		lua_pushnil (L);
-	else
-		lua_pushlstring (L, row, len);
-}
-
-
-/*
-** Get the internal database type of the given column.
-*/
-static char *getcolumntype (enum enum_field_types type) {
-
-	switch (type) {
-		case MYSQL_TYPE_VAR_STRING: case MYSQL_TYPE_STRING:
-			return "string";
-		case MYSQL_TYPE_DECIMAL: case MYSQL_TYPE_SHORT: case MYSQL_TYPE_LONG:
-		case MYSQL_TYPE_FLOAT: case MYSQL_TYPE_DOUBLE: case MYSQL_TYPE_LONGLONG:
-		case MYSQL_TYPE_INT24: case MYSQL_TYPE_YEAR: case MYSQL_TYPE_TINY: 
-			return "number";
-		case MYSQL_TYPE_TINY_BLOB: case MYSQL_TYPE_MEDIUM_BLOB:
-		case MYSQL_TYPE_LONG_BLOB: case MYSQL_TYPE_BLOB:
-			return "binary";
-		case MYSQL_TYPE_DATE: case MYSQL_TYPE_NEWDATE:
-			return "date";
-		case MYSQL_TYPE_DATETIME:
-			return "datetime";
-		case MYSQL_TYPE_TIME:
-			return "time";
-		case MYSQL_TYPE_TIMESTAMP:
-			return "timestamp";
-		case MYSQL_TYPE_ENUM: case MYSQL_TYPE_SET:
-			return "set";
-		case MYSQL_TYPE_NULL:
-			return "null";
-		default:
-			return "undefined";
-	}
-}
-
-
-/*
-** Creates the lists of fields names and fields types.
-*/
-static void create_colinfo (lua_State *L, cur_data *cur) {
-	MYSQL_FIELD *fields;
-	char typename[50];
-	int i;
-	fields = mysql_fetch_fields(cur->my_res);
-	lua_newtable (L); /* names */
-	lua_newtable (L); /* types */
-	for (i = 1; i <= cur->numcols; i++) {
-		lua_pushstring (L, fields[i-1].name);
-		lua_rawseti (L, -3, i);
-		sprintf (typename, "%.20s(%ld)", getcolumntype (fields[i-1].type), fields[i-1].length);
-		lua_pushstring(L, typename);
-		lua_rawseti (L, -2, i);
-	}
-	/* Stores the references in the cursor structure */
-	cur->coltypes = luaL_ref (L, LUA_REGISTRYINDEX);
-	cur->colnames = luaL_ref (L, LUA_REGISTRYINDEX);
-}
-
-
-/*
-** Get another row of the given cursor.
-*/
-static int cur_fetch (lua_State *L) {
-	cur_data *cur = getcursor (L);
-	MYSQL_RES *res = cur->my_res;
-	unsigned long *lengths;
-	MYSQL_ROW row = mysql_fetch_row(res);
-	if (row == NULL) {
-		lua_pushnil(L);  /* no more results */
-		return 1;
-	}
-	lengths = mysql_fetch_lengths(res);
-
-	if (lua_istable (L, 2)) {
-		const char *opts = luaL_optstring (L, 3, "n");
-		if (strchr (opts, 'n') != NULL) {
-			/* Copy values to numerical indices */
-			int i;
-			for (i = 0; i < cur->numcols; i++) {
-				pushvalue (L, row[i], lengths[i]);
-				lua_rawseti (L, 2, i+1);
-			}
-		}
-		if (strchr (opts, 'a') != NULL) {
-			int i;
-			/* Check if colnames exists */
-			if (cur->colnames == LUA_NOREF)
-		        create_colinfo(L, cur);
-			lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);/* Push colnames*/
-	
-			/* Copy values to alphanumerical indices */
-			for (i = 0; i < cur->numcols; i++) {
-				lua_rawgeti(L, -1, i+1); /* push the field name */
-
-				/* Actually push the value */
-				pushvalue (L, row[i], lengths[i]);
-				lua_rawset (L, 2);
-			}
-			/* lua_pop(L, 1);  Pops colnames table. Not needed */
-		}
-		lua_pushvalue(L, 2);
-		return 1; /* return table */
-	}
-	else {
-		int i;
-		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
-		for (i = 0; i < cur->numcols; i++)
-			pushvalue (L, row[i], lengths[i]);
-		return cur->numcols; /* return #numcols values */
-	}
-}
-
-
-/*
-** Close the cursor on top of the stack.
-** Return 1
-*/
-static int cur_close (lua_State *L) {
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_MYSQL);
-	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	if (cur->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-
-	/* Nullify structure fields. */
-	cur->closed = 1;
-	mysql_free_result(cur->my_res);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
-
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-/*
-** Pushes a column information table on top of the stack.
-** If the table isn't built yet, call the creator function and stores
-** a reference to it on the cursor structure.
-*/
-static void _pushtable (lua_State *L, cur_data *cur, size_t off) {
-	int *ref = (int *)((char *)cur + off);
-
-	/* If colnames or coltypes do not exist, create both. */
-	if (*ref == LUA_NOREF)
-		create_colinfo(L, cur);
-	
-	/* Pushes the right table (colnames or coltypes) */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, *ref);
-}
-#define pushtable(L,c,m) (_pushtable(L,c,offsetof(cur_data,m)))
-
-
-/*
-** Return the list of field names.
-*/
-static int cur_getcolnames (lua_State *L) {
-	pushtable (L, getcursor(L), colnames);
-	return 1;
-}
-
-
-/*
-** Return the list of field types.
-*/
-static int cur_getcoltypes (lua_State *L) {
-	pushtable (L, getcursor(L), coltypes);
-	return 1;
-}
-
-
-/*
-** Push the number of rows.
-*/
-static int cur_numrows (lua_State *L) {
-	lua_pushnumber (L, (lua_Number)mysql_num_rows (getcursor(L)->my_res));
-	return 1;
-}
-
-
-/*
-** Create a new Cursor object and push it on top of the stack.
-*/
-static int create_cursor (lua_State *L, int conn, MYSQL_RES *result, int cols) {
-	cur_data *cur = (cur_data *)lua_newuserdata(L, sizeof(cur_data));
-	luasql_setmeta (L, LUASQL_CURSOR_MYSQL);
-
-	/* fill in structure */
-	cur->closed = 0;
-	cur->conn = LUA_NOREF;
-	cur->numcols = cols;
-	cur->colnames = LUA_NOREF;
-	cur->coltypes = LUA_NOREF;
-	cur->my_res = result;
-	lua_pushvalue (L, conn);
-	cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
-
-	return 1;
-}
-
-
-/*
-** Close a Connection object.
-*/
-static int conn_close (lua_State *L) {
-	conn_data *conn=(conn_data *)luaL_checkudata(L, 1, LUASQL_CONNECTION_MYSQL);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	if (conn->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-
-	/* Nullify structure fields. */
-	conn->closed = 1;
-	luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
-	mysql_close (conn->my_conn);
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-static int escape_string (lua_State *L) {
-  size_t size, new_size;
-  conn_data *conn = getconnection (L);
-  const char *from = luaL_checklstring(L, 2, &size);
-  char *to;
-  to = (char*)malloc(sizeof(char) * (2 * size + 1));
-  if(to) {
-    new_size = mysql_real_escape_string(conn->my_conn, to, from, size);
-    lua_pushlstring(L, to, new_size);
-    free(to);
-    return 1;
-  }
-  luaL_error(L, "could not allocate escaped string");
-  return 0;
-}
-
-/*
-** Execute an SQL statement.
-** Return a Cursor object if the statement is a query, otherwise
-** return the number of tuples affected by the statement.
-*/
-static int conn_execute (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	const char *statement = luaL_checkstring (L, 2);
-	unsigned long st_len = strlen(statement);
-	if (mysql_real_query(conn->my_conn, statement, st_len)) 
-		/* error executing query */
-		return luasql_failmessage(L, "Error executing query. MySQL: ", mysql_error(conn->my_conn));
-	else
-	{
-		MYSQL_RES *res = mysql_store_result(conn->my_conn);
-		unsigned int num_cols = mysql_field_count(conn->my_conn);
-
-		if (res) { /* tuples returned */
-			return create_cursor (L, 1, res, num_cols);
-		}
-		else { /* mysql_use_result() returned nothing; should it have? */
-			if(num_cols == 0) { /* no tuples returned */
-            	/* query does not return data (it was not a SELECT) */
-				lua_pushnumber(L, mysql_affected_rows(conn->my_conn));
-				return 1;
-        	}
-			else /* mysql_use_result() should have returned data */
-				return luasql_failmessage(L, "Error retrieving result. MySQL: ", mysql_error(conn->my_conn));
-		}
-	}
-}
-
-
-/*
-** Commit the current transaction.
-*/
-static int conn_commit (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	lua_pushboolean(L, !mysql_commit(conn->my_conn));
-	return 1;
-}
-
-
-/*
-** Rollback the current transaction.
-*/
-static int conn_rollback (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	lua_pushboolean(L, !mysql_rollback(conn->my_conn));
-	return 1;
-}
-
-
-/*
-** Set "auto commit" property of the connection. Modes ON/OFF
-*/
-static int conn_setautocommit (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	if (lua_toboolean (L, 2)) {
-		mysql_autocommit(conn->my_conn, 1); /* Set it ON */
-	}
-	else {
-		mysql_autocommit(conn->my_conn, 0);
-	}
-	lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Get Last auto-increment id generated
-*/
-static int conn_getlastautoid (lua_State *L) {
-  conn_data *conn = getconnection(L);
-  lua_pushnumber(L, mysql_insert_id(conn->my_conn));
-  return 1;
-}
-
-/*
-** Create a new Connection object and push it on top of the stack.
-*/
-static int create_connection (lua_State *L, int env, MYSQL *const my_conn) {
-	conn_data *conn = (conn_data *)lua_newuserdata(L, sizeof(conn_data));
-	luasql_setmeta (L, LUASQL_CONNECTION_MYSQL);
-
-	/* fill in structure */
-	conn->closed = 0;
-	conn->env = LUA_NOREF;
-	conn->my_conn = my_conn;
-	lua_pushvalue (L, env);
-	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
-	return 1;
-}
-
-
-/*
-** Connects to a data source.
-**     param: one string for each connection parameter, said
-**     datasource, username, password, host and port.
-*/
-static int env_connect (lua_State *L) {
-	const char *sourcename = luaL_checkstring(L, 2);
-	const char *username = luaL_optstring(L, 3, NULL);
-	const char *password = luaL_optstring(L, 4, NULL);
-	const char *host = luaL_optstring(L, 5, NULL);
-	const int port = luaL_optint(L, 6, 0);
-	MYSQL *conn;
-	getenvironment(L); /* validade environment */
-
-	/* Try to init the connection object. */
-	conn = mysql_init(NULL);
-	if (conn == NULL)
-		return luasql_faildirect(L, LUASQL_PREFIX"Error connecting: Out of memory.");
-
-	if (!mysql_real_connect(conn, host, username, password, 
-		sourcename, port, NULL, 0))
-	{
-		char error_msg[100];
-		strncpy (error_msg,  mysql_error(conn), 99);
-		mysql_close (conn); /* Close conn if connect failed */
-		return luasql_failmessage (L, "Error connecting to database. MySQL: ", error_msg);
-	}
-	return create_connection(L, 1, conn);
-}
-
-
-/*
-** Close environment object.
-*/
-static int env_close (lua_State *L) {
-	env_data *env= (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_MYSQL);
-	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	if (env->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-
-	env->closed = 1;
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-/*
-** Create metatables for each class of object.
-*/
-static void create_metatables (lua_State *L) {
-    struct luaL_reg environment_methods[] = {
-        {"__gc", env_close},
-        {"close", env_close},
-        {"connect", env_connect},
-		{NULL, NULL},
-	};
-    struct luaL_reg connection_methods[] = {
-        {"__gc", conn_close},
-        {"close", conn_close},
-        {"escape", escape_string},
-        {"execute", conn_execute},
-        {"commit", conn_commit},
-        {"rollback", conn_rollback},
-        {"setautocommit", conn_setautocommit},
-		{"getlastautoid", conn_getlastautoid},
-		{NULL, NULL},
-    };
-    struct luaL_reg cursor_methods[] = {
-        {"__gc", cur_close},
-        {"close", cur_close},
-        {"getcolnames", cur_getcolnames},
-        {"getcoltypes", cur_getcoltypes},
-        {"fetch", cur_fetch},
-        {"numrows", cur_numrows},
-		{NULL, NULL},
-    };
-	luasql_createmeta (L, LUASQL_ENVIRONMENT_MYSQL, environment_methods);
-	luasql_createmeta (L, LUASQL_CONNECTION_MYSQL, connection_methods);
-	luasql_createmeta (L, LUASQL_CURSOR_MYSQL, cursor_methods);
-	lua_pop (L, 3);
-}
-
-
-/*
-** Creates an Environment and returns it.
-*/
-static int create_environment (lua_State *L) {
-	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
-	luasql_setmeta (L, LUASQL_ENVIRONMENT_MYSQL);
-
-	/* fill in structure */
-	env->closed = 0;
-	return 1;
-}
-
-
-/*
-** Creates the metatables for the objects and registers the
-** driver open method.
-*/
-LUASQL_API int luaopen_luasql_mysql (lua_State *L) { 
-	struct luaL_reg driver[] = {
-		{"mysql", create_environment},
-		{NULL, NULL},
-	};
-	create_metatables (L);
-	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
-	luasql_set_info (L);
-    lua_pushliteral (L, "_MYSQLVERSION");
-    lua_pushliteral (L, MYSQL_SERVER_VERSION);
-    lua_settable (L, -3);
-	return 1;
-}
+/*
+** LuaSQL, MySQL driver
+** Authors:  Eduardo Quintao
+** See Copyright Notice in license.html
+** $Id: ls_mysql.c,v 1.29 2008/05/04 02:46:17 tomas Exp $
+*/
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#ifdef WIN32
+#include <winsock2.h>
+#define NO_CLIENT_LONG_LONG
+#endif
+
+#include "mysql.h"
+
+#include "lua.h"
+#include "lauxlib.h"
+#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
+#include "compat-5.1.h"
+#endif
+
+
+#include "luasql.h"
+
+#define LUASQL_ENVIRONMENT_MYSQL "MySQL environment"
+#define LUASQL_CONNECTION_MYSQL "MySQL connection"
+#define LUASQL_CURSOR_MYSQL "MySQL cursor"
+
+/* For compat with old version 4.0 */
+#if (MYSQL_VERSION_ID < 40100) 
+#define MYSQL_TYPE_VAR_STRING   FIELD_TYPE_VAR_STRING 
+#define MYSQL_TYPE_STRING       FIELD_TYPE_STRING 
+#define MYSQL_TYPE_DECIMAL      FIELD_TYPE_DECIMAL 
+#define MYSQL_TYPE_SHORT        FIELD_TYPE_SHORT 
+#define MYSQL_TYPE_LONG         FIELD_TYPE_LONG 
+#define MYSQL_TYPE_FLOAT        FIELD_TYPE_FLOAT 
+#define MYSQL_TYPE_DOUBLE       FIELD_TYPE_DOUBLE 
+#define MYSQL_TYPE_LONGLONG     FIELD_TYPE_LONGLONG 
+#define MYSQL_TYPE_INT24        FIELD_TYPE_INT24 
+#define MYSQL_TYPE_YEAR         FIELD_TYPE_YEAR 
+#define MYSQL_TYPE_TINY         FIELD_TYPE_TINY 
+#define MYSQL_TYPE_TINY_BLOB    FIELD_TYPE_TINY_BLOB 
+#define MYSQL_TYPE_MEDIUM_BLOB  FIELD_TYPE_MEDIUM_BLOB 
+#define MYSQL_TYPE_LONG_BLOB    FIELD_TYPE_LONG_BLOB 
+#define MYSQL_TYPE_BLOB         FIELD_TYPE_BLOB 
+#define MYSQL_TYPE_DATE         FIELD_TYPE_DATE 
+#define MYSQL_TYPE_NEWDATE      FIELD_TYPE_NEWDATE 
+#define MYSQL_TYPE_DATETIME     FIELD_TYPE_DATETIME 
+#define MYSQL_TYPE_TIME         FIELD_TYPE_TIME 
+#define MYSQL_TYPE_TIMESTAMP    FIELD_TYPE_TIMESTAMP 
+#define MYSQL_TYPE_ENUM         FIELD_TYPE_ENUM 
+#define MYSQL_TYPE_SET          FIELD_TYPE_SET
+#define MYSQL_TYPE_NULL         FIELD_TYPE_NULL
+
+#define mysql_commit(_) ((void)_)
+#define mysql_rollback(_) ((void)_)
+#define mysql_autocommit(_,__) ((void)_)
+
+#endif
+
+typedef struct {
+	short      closed;
+} env_data;
+
+typedef struct {
+	short      closed;
+	int        env;                /* reference to environment */
+	MYSQL     *my_conn;
+	int		   auto_commit;		/* should each statment be commited */
+} conn_data;
+
+typedef struct {
+	short      closed;
+	int        conn;               /* reference to connection */
+	int        numcols;            /* number of columns */
+	int        colnames, coltypes; /* reference to column information tables */
+	MYSQL_RES *my_res;
+	char	  *modestring;
+} cur_data;
+
+LUASQL_API int luaopen_luasql_mysql (lua_State *L);
+
+
+/*
+** Generates a driver error plus the error message from the database
+** The generated error message is preceded by LUASQL_PREFIX string
+*/
+static int luasql_failmessage(lua_State *L, const char *err, const char *m) {
+    lua_pushnil(L);
+	lua_pushstring(L, LUASQL_PREFIX);
+	lua_pushstring(L, err);
+    lua_pushstring(L, m);
+	lua_concat(L, 3);
+    return 2;
+}
+
+
+/*
+** Check for valid environment.
+*/
+static env_data *getenvironment (lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_MYSQL);
+	luaL_argcheck (L, env != NULL, 1, "environment expected");
+	luaL_argcheck (L, !env->closed, 1, "environment is closed");
+	return env;
+}
+
+
+/*
+** Check for valid connection.
+*/
+static conn_data *getconnection (lua_State *L) {
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_MYSQL);
+	luaL_argcheck (L, conn != NULL, 1, "connection expected");
+	luaL_argcheck (L, !conn->closed, 1, "connection is closed");
+	return conn;
+}
+
+
+/*
+** Check for valid cursor.
+*/
+static cur_data *getcursor (lua_State *L) {
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_MYSQL);
+	luaL_argcheck (L, cur != NULL, 1, "cursor expected");
+	luaL_argcheck (L, !cur->closed, 1, "cursor is closed");
+	return cur;
+}
+
+
+/*
+** Push the value of #i field of #tuple row.
+*/
+static void pushvalue (lua_State *L, void *row, long int len) {
+	if (row == NULL)
+		lua_pushnil (L);
+	else
+		lua_pushlstring (L, row, len);
+}
+
+
+/*
+** Get the internal database type of the given column.
+*/
+static char *getcolumntype (enum enum_field_types type) {
+
+	switch (type) {
+		case MYSQL_TYPE_VAR_STRING: case MYSQL_TYPE_STRING:
+			return "string";
+		case MYSQL_TYPE_DECIMAL: case MYSQL_TYPE_SHORT: case MYSQL_TYPE_LONG:
+		case MYSQL_TYPE_FLOAT: case MYSQL_TYPE_DOUBLE: case MYSQL_TYPE_LONGLONG:
+		case MYSQL_TYPE_INT24: case MYSQL_TYPE_YEAR: case MYSQL_TYPE_TINY: 
+			return "number";
+		case MYSQL_TYPE_TINY_BLOB: case MYSQL_TYPE_MEDIUM_BLOB:
+		case MYSQL_TYPE_LONG_BLOB: case MYSQL_TYPE_BLOB:
+			return "binary";
+		case MYSQL_TYPE_DATE: case MYSQL_TYPE_NEWDATE:
+			return "date";
+		case MYSQL_TYPE_DATETIME:
+			return "datetime";
+		case MYSQL_TYPE_TIME:
+			return "time";
+		case MYSQL_TYPE_TIMESTAMP:
+			return "timestamp";
+		case MYSQL_TYPE_ENUM: case MYSQL_TYPE_SET:
+			return "set";
+		case MYSQL_TYPE_NULL:
+			return "null";
+		default:
+			return "undefined";
+	}
+}
+
+
+/*
+** Creates the lists of fields names and fields types.
+*/
+static void create_colinfo (lua_State *L, cur_data *cur) {
+	MYSQL_FIELD *fields;
+	char typename[50];
+	int i;
+	fields = mysql_fetch_fields(cur->my_res);
+	lua_newtable (L); /* names */
+	lua_newtable (L); /* types */
+	for (i = 1; i <= cur->numcols; i++) {
+		lua_pushstring (L, fields[i-1].name);
+		lua_rawseti (L, -3, i);
+		sprintf (typename, "%.20s(%ld)", getcolumntype (fields[i-1].type), fields[i-1].length);
+		lua_pushstring(L, typename);
+		lua_rawseti (L, -2, i);
+	}
+	/* Stores the references in the cursor structure */
+	cur->coltypes = luaL_ref (L, LUA_REGISTRYINDEX);
+	cur->colnames = luaL_ref (L, LUA_REGISTRYINDEX);
+}
+
+
+/*
+** Get another row of the given cursor.
+*/
+static int cur_fetch (lua_State *L) {
+	cur_data *cur = getcursor (L);
+	MYSQL_RES *res = cur->my_res;
+	unsigned long *lengths;
+	MYSQL_ROW row = mysql_fetch_row(res);
+	if (row == NULL) {
+		lua_pushnil(L);  /* no more results */
+		return 1;
+	}
+	lengths = mysql_fetch_lengths(res);
+
+	if (lua_istable (L, 2)) {
+	    const char *opts = luasql_getfetchmodestring( L, cur->modestring );
+		if (strchr (opts, 'n') != NULL) {
+			/* Copy values to numerical indices */
+			int i;
+			for (i = 0; i < cur->numcols; i++) {
+				pushvalue (L, row[i], lengths[i]);
+				lua_rawseti (L, 2, i+1);
+			}
+		}
+		if (strchr (opts, 'a') != NULL) {
+			int i;
+			/* Check if colnames exists */
+			if (cur->colnames == LUA_NOREF)
+		        create_colinfo(L, cur);
+			lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);/* Push colnames*/
+	
+			/* Copy values to alphanumerical indices */
+			for (i = 0; i < cur->numcols; i++) {
+				lua_rawgeti(L, -1, i+1); /* push the field name */
+
+				/* Actually push the value */
+				pushvalue (L, row[i], lengths[i]);
+				lua_rawset (L, 2);
+			}
+			/* lua_pop(L, 1);  Pops colnames table. Not needed */
+		}
+		lua_pushvalue(L, 2);
+		return 1; /* return table */
+	}
+	else {
+		int i;
+		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
+		for (i = 0; i < cur->numcols; i++)
+			pushvalue (L, row[i], lengths[i]);
+		return cur->numcols; /* return #numcols values */
+	}
+}
+
+
+/*
+** Close the cursor on top of the stack.
+** Return 1
+*/
+static int cur_close (lua_State *L) {
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_MYSQL);
+	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	if (cur->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+
+	/* Nullify structure fields. */
+	cur->closed = 1;
+	mysql_free_result(cur->my_res);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
+
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+** Pushes a column information table on top of the stack.
+** If the table isn't built yet, call the creator function and stores
+** a reference to it on the cursor structure.
+*/
+static void _pushtable (lua_State *L, cur_data *cur, size_t off) {
+	int *ref = (int *)((char *)cur + off);
+
+	/* If colnames or coltypes do not exist, create both. */
+	if (*ref == LUA_NOREF)
+		create_colinfo(L, cur);
+	
+	/* Pushes the right table (colnames or coltypes) */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, *ref);
+}
+#define pushtable(L,c,m) (_pushtable(L,c,offsetof(cur_data,m)))
+
+
+/*
+** Return the list of field names.
+*/
+static int cur_getcolnames (lua_State *L) {
+	pushtable (L, getcursor(L), colnames);
+	return 1;
+}
+
+
+/*
+** Return the list of field types.
+*/
+static int cur_getcoltypes (lua_State *L) {
+	pushtable (L, getcursor(L), coltypes);
+	return 1;
+}
+
+
+/*
+** Push the number of rows.
+*/
+static int cur_numrows (lua_State *L) {
+	lua_pushnumber (L, (lua_Number)mysql_num_rows (getcursor(L)->my_res));
+	return 1;
+}
+
+
+/*
+ * Sets the cursor parameters
+ */
+static void cur_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					if( lua_isstring( L, -1 ) )
+						cur->modestring = lua_tostring( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified cursor parameters
+ */
+static int cur_get( lua_State *L ) {
+	if( lua_istable( L, 2 ) ) {
+		lua_newtable(L);
+		int rsp = lua_gettop(L);
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					lua_pushstring( L, LUASQL_MODESTRING );
+					lua_pushstring( L, cur->modestring );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+				cur_data *cur = getcursor(L);
+				lua_pushstring( L, cur->modestring );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Cursor object and push it on top of the stack.
+*/
+static int create_cursor (lua_State *L, int conn, MYSQL_RES *result, int cols) {
+	cur_data *cur = (cur_data *)lua_newuserdata(L, sizeof(cur_data));
+	luasql_setmeta (L, LUASQL_CURSOR_MYSQL);
+
+	/* fill in structure */
+	cur->closed = 0;
+	cur->conn = LUA_NOREF;
+	cur->numcols = cols;
+	cur->colnames = LUA_NOREF;
+	cur->coltypes = LUA_NOREF;
+	cur->my_res = result;
+	cur->modestring = "n";
+	lua_pushvalue (L, conn);
+	cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
+
+	return 1;
+}
+
+
+/*
+** Close a Connection object.
+*/
+static int conn_close (lua_State *L) {
+	conn_data *conn=(conn_data *)luaL_checkudata(L, 1, LUASQL_CONNECTION_MYSQL);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	if (conn->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+
+	/* Nullify structure fields. */
+	conn->closed = 1;
+	luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
+	mysql_close (conn->my_conn);
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+static int escape_string (lua_State *L) {
+  size_t size, new_size;
+  conn_data *conn = getconnection (L);
+  const char *from = luaL_checklstring(L, 2, &size);
+  char *to;
+  to = (char*)malloc(sizeof(char) * (2 * size + 1));
+  if(to) {
+    new_size = mysql_real_escape_string(conn->my_conn, to, from, size);
+    lua_pushlstring(L, to, new_size);
+    free(to);
+    return 1;
+  }
+  luaL_error(L, "could not allocate escaped string");
+  return 0;
+}
+
+/*
+** Execute an SQL statement.
+** Return a Cursor object if the statement is a query, otherwise
+** return the number of tuples affected by the statement.
+*/
+static int conn_execute (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	const char *statement = luaL_checkstring (L, 2);
+	unsigned long st_len = strlen(statement);
+	if (mysql_real_query(conn->my_conn, statement, st_len)) 
+		/* error executing query */
+		return luasql_failmessage(L, "Error executing query. MySQL: ", mysql_error(conn->my_conn));
+	else
+	{
+		MYSQL_RES *res = mysql_store_result(conn->my_conn);
+		unsigned int num_cols = mysql_field_count(conn->my_conn);
+
+		if (res) { /* tuples returned */
+			return create_cursor (L, 1, res, num_cols);
+		}
+		else { /* mysql_use_result() returned nothing; should it have? */
+			if(num_cols == 0) { /* no tuples returned */
+            	/* query does not return data (it was not a SELECT) */
+				lua_pushnumber(L, mysql_affected_rows(conn->my_conn));
+				return 1;
+        	}
+			else /* mysql_use_result() should have returned data */
+				return luasql_failmessage(L, "Error retrieving result. MySQL: ", mysql_error(conn->my_conn));
+		}
+	}
+}
+
+
+/*
+** Commit the current transaction.
+*/
+static int conn_commit (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	lua_pushboolean(L, !mysql_commit(conn->my_conn));
+	return 1;
+}
+
+
+/*
+** Rollback the current transaction.
+*/
+static int conn_rollback (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	lua_pushboolean(L, !mysql_rollback(conn->my_conn));
+	return 1;
+}
+
+
+/*
+** Set "auto commit" property of the connection. Modes ON/OFF
+*/
+static void conn_dosetautocommit(lua_State *L, conn_data *conn, int pos){
+	if (lua_toboolean (L, pos)) {
+		mysql_autocommit(conn->my_conn, 1); /* Set it ON */
+		conn->auto_commit = 1;
+	}
+	else {
+		mysql_autocommit(conn->my_conn, 0);
+		conn->auto_commit = 0;
+	}
+}
+
+static int conn_setautocommit (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	conn_dosetautocommit(L, conn, 2);
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+** Get Last auto-increment id generated
+*/
+static int conn_getlastautoid (lua_State *L) {
+  conn_data *conn = getconnection(L);
+  lua_pushnumber(L, mysql_insert_id(conn->my_conn));
+  return 1;
+}
+
+/*
+ * Sets the connection parameters
+ */
+static void conn_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					if( lua_isboolean( L, -1 ) )
+						conn_dosetautocommit(L, conn, -1);
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified connection parameters
+ */
+static int conn_get( lua_State *L ) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					lua_pushstring( L, LUASQL_AUTOCOMMIT );
+					lua_pushboolean( L, conn->auto_commit );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+				conn_data *conn = getconnection(L);
+				lua_pushboolean( L, conn->auto_commit );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Connection object and push it on top of the stack.
+*/
+static int create_connection (lua_State *L, int env, MYSQL *const my_conn) {
+	conn_data *conn = (conn_data *)lua_newuserdata(L, sizeof(conn_data));
+	luasql_setmeta (L, LUASQL_CONNECTION_MYSQL);
+
+	/* fill in structure */
+	conn->closed = 0;
+	conn->env = LUA_NOREF;
+	conn->my_conn = my_conn;
+	conn->auto_commit = 1;
+	lua_pushvalue (L, env);
+	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
+	return 1;
+}
+
+
+/*
+** Connects to a data source.
+**     param: one string for each connection parameter, said
+**     datasource, username, password, host and port.
+*/
+static int env_connect (lua_State *L) {
+	char *sourcename = NULL;
+	char *username = NULL;
+	char *password = NULL;
+	char *host = NULL;
+	int port = 0;
+	MYSQL *conn;
+	getenvironment(L); /* validade environment */
+
+	if( lua_istable( L, 2 ) ) {
+		lua_pushstring( L, LUASQL_SOURCENAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			sourcename = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );		
+		lua_pushstring( L, LUASQL_USERNAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			username = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_PASSWORD );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			password = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_HOSTNAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			host = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_PORT );
+		lua_gettable( L, 2 );
+		
+		if( lua_isnumber( L, -1 ) )
+			port = lua_tointeger( L, -1 );
+
+		lua_pop( L, 1 );
+	} else {
+		sourcename = luaL_checkstring(L, 2);
+		username = luaL_optstring(L, 3, NULL);
+		password = luaL_optstring(L, 4, NULL);
+		host = luaL_optstring(L, 5, NULL);
+		port = luaL_optint(L, 6, 0);
+	}
+
+	/* Try to init the connection object. */
+	conn = mysql_init(NULL);
+	if (conn == NULL)
+		return luasql_faildirect(L, LUASQL_PREFIX"Error connecting: Out of memory.");
+
+	if (!mysql_real_connect(conn, host, username, password, 
+		sourcename, port, NULL, 0))
+	{
+		char error_msg[100];
+		strncpy (error_msg,  mysql_error(conn), 99);
+		mysql_close (conn); /* Close conn if connect failed */
+		return luasql_failmessage (L, "Error connecting to database. MySQL: ", error_msg);
+	}
+	return create_connection(L, 1, conn);
+}
+
+
+/*
+** Close environment object.
+*/
+static int env_close (lua_State *L) {
+	env_data *env= (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_MYSQL);
+	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	if (env->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+
+	env->closed = 1;
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+ * Sets the environment parameters
+ */
+static void env_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					if( lua_isnumber( L, -1 ) )
+						env->locktimeout = lua_tointeger( L, -1 );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+/*
+ * Retrieve the specified environment parameters
+ */
+static int env_get(lua_State *L) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+					lua_pushinteger( L, env->locktimeout );
+					lua_settable( L, rsp );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+/*
+			if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+				env_data *env = getenvironment(L);
+				lua_pushinteger( L, env->locktimeout );
+			} else */
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create metatables for each class of object.
+*/
+static void create_metatables (lua_State *L) {
+    struct luaL_reg environment_methods[] = {
+        {"__gc", env_close},
+        {"close", env_close},
+        {"connect", env_connect},
+	    {"get", env_get},
+	    {"set", env_set},
+		{NULL, NULL},
+	};
+    struct luaL_reg connection_methods[] = {
+        {"__gc", conn_close},
+        {"close", conn_close},
+        {"escape", escape_string},
+        {"execute", conn_execute},
+        {"commit", conn_commit},
+        {"rollback", conn_rollback},
+        {"setautocommit", conn_setautocommit},
+		{"getlastautoid", conn_getlastautoid},
+	    {"get", conn_get},
+	    {"set", conn_set},
+		{NULL, NULL},
+    };
+    struct luaL_reg cursor_methods[] = {
+        {"__gc", cur_close},
+        {"close", cur_close},
+        {"getcolnames", cur_getcolnames},
+        {"getcoltypes", cur_getcoltypes},
+        {"fetch", cur_fetch},
+        {"numrows", cur_numrows},
+	    {"get", cur_get},
+	    {"set", cur_set},
+		{NULL, NULL},
+    };
+	luasql_createmeta (L, LUASQL_ENVIRONMENT_MYSQL, environment_methods);
+	luasql_createmeta (L, LUASQL_CONNECTION_MYSQL, connection_methods);
+	luasql_createmeta (L, LUASQL_CURSOR_MYSQL, cursor_methods);
+	lua_pop (L, 3);
+}
+
+
+/*
+** Creates an Environment and returns it.
+*/
+static int create_environment (lua_State *L) {
+	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
+	luasql_setmeta (L, LUASQL_ENVIRONMENT_MYSQL);
+
+	/* fill in structure */
+	env->closed = 0;
+	return 1;
+}
+
+
+/*
+** Creates the metatables for the objects and registers the
+** driver open method.
+*/
+LUASQL_API int luaopen_luasql_mysql (lua_State *L) { 
+	struct luaL_reg driver[] = {
+		{"mysql", create_environment},
+		{NULL, NULL},
+	};
+	create_metatables (L);
+	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
+	luasql_set_info (L);
+    lua_pushliteral (L, "_MYSQLVERSION");
+    lua_pushliteral (L, MYSQL_SERVER_VERSION);
+    lua_settable (L, -3);
+	return 1;
+}
Index: src/luasql.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/luasql.c,v
retrieving revision 1.26
diff -u -r1.26 luasql.c
--- src/luasql.c	12 Jul 2008 15:11:46 -0000	1.26
+++ src/luasql.c	2 Aug 2008 00:31:39 -0000
@@ -52,7 +52,7 @@
 
 	/* define metamethods */
 	lua_pushliteral (L, "__index");
-	lua_pushvalue (L, -2);
+	lua_pushvalue (L, -2); 
 	lua_settable (L, -3);
 
 	lua_pushliteral (L, "__tostring");
@@ -91,3 +91,27 @@
 	lua_pushliteral (L, "LuaSQL 2.1.2");
 	lua_settable (L, -3);
 }
+
+
+/*
+** Get the mode string value from cur:fetch parameters
+*/
+LUASQL_API char* luasql_getfetchmodestring( lua_State *L, const char *msdefault ) {
+	char* opts = msdefault;
+	
+	/* verify if the second parameter is a table */
+  	if( lua_istable( L, 3 ) ) {
+  		lua_pushstring( L, LUASQL_MODESTRING );
+  		lua_gettable( L, 3 );
+  		
+  		if( lua_isstring( L, -1 ) )
+  			opts = lua_tostring( L, -1 );
+  		
+  		lua_pop( L, 1 );
+  	} else {
+  		if( lua_isstring( L, 3 ) )
+  			opts = lua_tostring( L, 3 );
+  	}
+
+	return opts;
+}
Index: src/ls_sqlite3.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/ls_sqlite3.c,v
retrieving revision 1.12
diff -u -r1.12 ls_sqlite3.c
--- src/ls_sqlite3.c	11 Jun 2008 00:26:13 -0000	1.12
+++ src/ls_sqlite3.c	2 Aug 2008 00:31:39 -0000
@@ -1,637 +1,869 @@
-/*
-** LuaSQL, SQLite driver
-** Author: Tiago Dionizio, Eduardo Quintao
-** See Copyright Notice in license.html
-
-** $Id: ls_sqlite3.c,v 1.12 2008/06/11 00:26:13 jasonsantos Exp $
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-#include "sqlite3.h"
-
-#include "lua.h"
-#include "lauxlib.h"
-#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
-#include "compat-5.1.h"
-#endif
-
-
-#include "luasql.h"
-
-#define LUASQL_ENVIRONMENT_SQLITE "SQLite3 environment"
-#define LUASQL_CONNECTION_SQLITE "SQLite3 connection"
-#define LUASQL_CURSOR_SQLITE "SQLite3 cursor"
-
-typedef struct
-{
-  short       closed;
-} env_data;
-
-
-typedef struct
-{
-  short        closed;
-  int          env;                /* reference to environment */
-  short        auto_commit;        /* 0 for manual commit */
-  unsigned int cur_counter;          
-  sqlite3      *sql_conn;
-} conn_data;
-
-
-typedef struct
-{
-  short       closed;
-  int         conn;               /* reference to connection */
-  int         numcols;            /* number of columns */
-  int         colnames, coltypes; /* reference to column information tables */
-  conn_data   *conn_data;         /* reference to connection for cursor */
-  sqlite3_stmt  *sql_vm;
-} cur_data;
-
-LUASQL_API int luaopen_luasql_sqlite3(lua_State *L);
-
-
-/*
-** Check for valid environment.
-*/
-static env_data *getenvironment(lua_State *L) {
-  env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
-  luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-  luaL_argcheck(L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
-  return env;
-}
-
-
-/*
-** Check for valid connection.
-*/
-static conn_data *getconnection(lua_State *L) {
-  conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_SQLITE);
-  luaL_argcheck(L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-  luaL_argcheck(L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
-  return conn;
-}
-
-
-/*
-** Check for valid cursor.
-*/
-static cur_data *getcursor(lua_State *L) {
-  cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_SQLITE);
-  luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-  luaL_argcheck(L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
-  return cur;
-}
-
-/*
-** Finalizes the vm
-** Return nil + errmsg or nil in case of sucess
-*/
-static int finalize(lua_State *L, cur_data *cur) {
-  const char *errmsg;
-  if (sqlite3_finalize(cur->sql_vm) != SQLITE_OK)
-    {
-      errmsg = sqlite3_errmsg(cur->conn_data->sql_conn);
-      cur->sql_vm = NULL;
-      lua_pushnil(L);
-      lua_pushliteral(L, LUASQL_PREFIX);
-      lua_pushstring(L, errmsg);
-      lua_concat(L, 2);
-      return 2;
-    }
-  cur->sql_vm = NULL;
-  lua_pushnil(L);
-  return 1;
-}
-
-
-static void push_column(lua_State *L, sqlite3_stmt *vm, int column) {
-  switch (sqlite3_column_type(vm, column)) {
-  case SQLITE_INTEGER:
-    lua_pushinteger(L, sqlite3_column_int64(vm, column));
-    break;
-  case SQLITE_FLOAT:
-    lua_pushnumber(L, sqlite3_column_double(vm, column));
-    break;
-  case SQLITE_TEXT:
-    lua_pushlstring(L, sqlite3_column_text(vm, column),
-		    sqlite3_column_bytes(vm, column));
-    break;
-  case SQLITE_BLOB:
-    lua_pushlstring(L, sqlite3_column_blob(vm, column),
-		    sqlite3_column_bytes(vm, column));
-    break;
-  case SQLITE_NULL:
-    lua_pushnil(L);
-    break;
-  default:
-    luaL_error(L, LUASQL_PREFIX"Unrecognized column type");
-    break;
-  }
-}
-
-/*
-** Get another row of the given cursor.
-*/
-static int cur_fetch (lua_State *L) {
-  cur_data *cur = getcursor(L);
-  sqlite3_stmt *vm = cur->sql_vm;
-  int res;
-
-  if (vm == NULL)
-    return 0;
-
-  res = sqlite3_step(vm);
-
-  /* no more results? */
-  if (res == SQLITE_DONE)
-    return finalize(L, cur);
-
-  if (res != SQLITE_ROW)
-    return finalize(L, cur);
-
-  if (lua_istable (L, 2))
-    {
-      int i;
-      const char *opts = luaL_optstring(L, 3, "n");
-
-      if (strchr(opts, 'n') != NULL)
-        {
-	  /* Copy values to numerical indices */
-	  for (i = 0; i < cur->numcols;)
-            {
-	      push_column(L, vm, i);
-	      lua_rawseti(L, 2, ++i);
-	    }
-        }
-      if (strchr(opts, 'a') != NULL)
-        {
-	  /* Copy values to alphanumerical indices */
-	  lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
-
-	  for (i = 0; i < cur->numcols; i++)
-            {
-	      lua_rawgeti(L, -1, i+1);
-	      push_column(L, vm, i);
-	      lua_rawset (L, 2);
-	    }
-        }
-      lua_pushvalue(L, 2);
-      return 1; /* return table */
-    }
-  else
-    {
-      int i;
-      luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
-      for (i = 0; i < cur->numcols; ++i)
-	push_column(L, vm, i);
-      return cur->numcols; /* return #numcols values */
-    }
-}
-
-
-/*
-** Close the cursor on top of the stack.
-** Return 1
-*/
-static int cur_close(lua_State *L)
-{
-  conn_data *conn;
-  cur_data *cur = (cur_data *)luaL_checkudata(L, 1, LUASQL_CURSOR_SQLITE);
-  luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-  if (cur->closed) {
-    lua_pushboolean(L, 0);
-    return 1;
-  }
-
-  /* Nullify structure fields. */
-  cur->closed = 1;
-  sqlite3_finalize(cur->sql_vm);
-  /* Decrement cursor counter on connection object */
-  lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
-  conn = lua_touserdata (L, -1);
-  conn->cur_counter--;
-
-  luaL_unref(L, LUA_REGISTRYINDEX, cur->conn);
-  luaL_unref(L, LUA_REGISTRYINDEX, cur->colnames);
-  luaL_unref(L, LUA_REGISTRYINDEX, cur->coltypes);
-
-  lua_pushboolean(L, 1);
-  return 1;
-}
-
-
-/*
-** Return the list of field names.
-*/
-static int cur_getcolnames(lua_State *L)
-{
-  cur_data *cur = getcursor(L);
-  lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
-  return 1;
-}
-
-
-/*
-** Return the list of field types.
-*/
-static int cur_getcoltypes(lua_State *L)
-{
-  cur_data *cur = getcursor(L);
-  lua_rawgeti(L, LUA_REGISTRYINDEX, cur->coltypes);
-  return 1;
-}
-
-
-/*
-** Create a new Cursor object and push it on top of the stack.
-*/
-/* static int create_cursor(lua_State *L, int conn, sqlite3_stmt *sql_vm,
-   int numcols, const char **row, const char **col_info)*/
-static int create_cursor(lua_State *L, int o, conn_data *conn, 
-			 sqlite3_stmt *sql_vm, int numcols)
-{
-  int i;
-  cur_data *cur = (cur_data*)lua_newuserdata(L, sizeof(cur_data));
-  luasql_setmeta (L, LUASQL_CURSOR_SQLITE);
-
-  /* increment cursor count for the connection creating this cursor */
-  conn->cur_counter++;
-
-  /* fill in structure */
-  cur->closed = 0;
-  cur->conn = LUA_NOREF;
-  cur->numcols = numcols;
-  cur->colnames = LUA_NOREF;
-  cur->coltypes = LUA_NOREF;
-  cur->sql_vm = sql_vm;
-  cur->conn_data = conn;
-
-  lua_pushvalue(L, o);
-  cur->conn = luaL_ref(L, LUA_REGISTRYINDEX);
-
-  /* create table with column names */
-  lua_newtable(L);
-  for (i = 0; i < numcols;)
-    {
-      lua_pushstring(L, sqlite3_column_name(sql_vm, i));
-      lua_rawseti(L, -2, ++i);
-    }
-  cur->colnames = luaL_ref(L, LUA_REGISTRYINDEX);
-	
-  /* create table with column types */
-  lua_newtable(L);
-  for (i = 0; i < numcols;)
-    {
-      lua_pushstring(L, sqlite3_column_decltype(sql_vm, i));
-      lua_rawseti(L, -2, ++i);
-    }
-  cur->coltypes = luaL_ref(L, LUA_REGISTRYINDEX);
-
-  return 1;
-}
-
-
-/*
-** Close a Connection object.
-*/
-static int conn_close(lua_State *L)
-{
-  conn_data *conn = (conn_data *)luaL_checkudata(L, 1, LUASQL_CONNECTION_SQLITE);
-  luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-  if (conn->closed) 
-    {
-      lua_pushboolean(L, 0);
-      return 1;
-    }
-
-  if (conn->cur_counter > 0)
-    return luaL_error (L, LUASQL_PREFIX"there are open cursors");
-
-  /* Nullify structure fields. */
-  conn->closed = 1;
-  luaL_unref(L, LUA_REGISTRYINDEX, conn->env);
-  sqlite3_close(conn->sql_conn);
-  lua_pushboolean(L, 1);
-  return 1;
-}
-
-static int conn_escape(lua_State *L)
-{
-  const char *from = luaL_checklstring (L, 2, 0);
-  char *escaped = sqlite3_mprintf("%q", from);
-  if (escaped == NULL) 
-    {
-      lua_pushnil(L);
-    } 
-  else
-    {
-      lua_pushstring(L, escaped);        
-      sqlite3_free(escaped);
-    }
-  return 1;
-}
-
-/*
-** Execute an SQL statement.
-** Return a Cursor object if the statement is a query, otherwise
-** return the number of tuples affected by the statement.
-*/
-static int conn_execute(lua_State *L)
-{
-  conn_data *conn = getconnection(L);
-  const char *statement = luaL_checkstring(L, 2);
-  int res;
-  sqlite3_stmt *vm;
-  const char *errmsg;
-  int numcols;
-  const char *tail;
-
-  res = sqlite3_prepare(conn->sql_conn, statement, -1, &vm, &tail);
-  if (res != SQLITE_OK)
-    {
-      errmsg = sqlite3_errmsg(conn->sql_conn);
-      lua_pushnil(L);
-      lua_pushliteral(L, LUASQL_PREFIX);
-      lua_pushstring(L, errmsg);
-      lua_concat(L, 2);
-      return 2;
-    }
-
-  /* process first result to retrive query information and type */
-  res = sqlite3_step(vm);
-  numcols = sqlite3_column_count(vm);
-
-  /* real query? if empty, must have numcols!=0 */
-  if ((res == SQLITE_ROW) || ((res == SQLITE_DONE) && numcols))
-    {
-      sqlite3_reset(vm);
-      return create_cursor(L, 1, conn, vm, numcols);
-    }
-
-  if (res == SQLITE_DONE) /* and numcols==0, INSERT,UPDATE,DELETE statement */
-    {
-      sqlite3_finalize(vm);
-      /* return number of columns changed */
-      lua_pushnumber(L, sqlite3_changes(conn->sql_conn));
-      return 1;
-    }
-
-  /* error */
-  errmsg = sqlite3_errmsg(conn->sql_conn);
-  sqlite3_finalize(vm);
-  lua_pushnil(L);
-  lua_pushliteral(L, LUASQL_PREFIX);
-  lua_pushstring(L, errmsg);
-  lua_concat(L, 2);
-  return 2;
-}
-
-
-/*
-** Commit the current transaction.
-*/
-static int conn_commit(lua_State *L)
-{
-  char *errmsg;
-  conn_data *conn = getconnection(L);
-  int res;
-  const char *sql = "COMMIT";
-
-  if (conn->auto_commit == 0) sql = "COMMIT;BEGIN";
-
-  res = sqlite3_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
-
-  if (res != SQLITE_OK)
-    {
-      lua_pushnil(L);
-      lua_pushliteral(L, LUASQL_PREFIX);
-      lua_pushstring(L, errmsg);
-      sqlite3_free(errmsg);
-      lua_concat(L, 2);
-      return 2;
-    }
-  lua_pushboolean(L, 1);
-  return 1;
-}
-
-
-/*
-** Rollback the current transaction.
-*/
-static int conn_rollback(lua_State *L)
-{
-  char *errmsg;
-  conn_data *conn = getconnection(L);
-  int res;
-  const char *sql = "ROLLBACK";
-
-  if (conn->auto_commit == 0) sql = "ROLLBACK;BEGIN";
-
-  res = sqlite3_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
-  if (res != SQLITE_OK)
-    {
-      lua_pushnil(L);
-      lua_pushliteral(L, LUASQL_PREFIX);
-      lua_pushstring(L, errmsg);
-      sqlite3_free(errmsg);
-      lua_concat(L, 2);
-      return 2;
-    }
-  lua_pushboolean(L, 1);
-  return 1;
-}
-
-static int conn_getlastautoid(lua_State *L)
-{
-  conn_data *conn = getconnection(L);
-  lua_pushnumber(L, sqlite3_last_insert_rowid(conn->sql_conn));
-  return 1;
-}
-
-
-/*
-** Set "auto commit" property of the connection.
-** If 'true', then rollback current transaction.
-** If 'false', then start a new transaction.
-*/
-static int conn_setautocommit(lua_State *L)
-{
-  conn_data *conn = getconnection(L);
-  if (lua_toboolean(L, 2))
-    {
-      conn->auto_commit = 1;
-      /* undo active transaction - ignore errors */
-      sqlite3_exec(conn->sql_conn, "ROLLBACK", NULL, NULL, NULL);
-    }
-  else
-    {
-      char *errmsg;
-      int res;
-      conn->auto_commit = 0;
-      res = sqlite3_exec(conn->sql_conn, "BEGIN", NULL, NULL, &errmsg);
-      if (res != SQLITE_OK)
-        {
-	  lua_pushliteral(L, LUASQL_PREFIX);
-	  lua_pushstring(L, errmsg);
-	  sqlite3_free(errmsg);
-	  lua_concat(L, 2);
-	  lua_error(L);
-        }
-    }
-  lua_pushboolean(L, 1);
-  return 1;
-}
-
-
-/*
-** Create a new Connection object and push it on top of the stack.
-*/
-static int create_connection(lua_State *L, int env, sqlite3 *sql_conn)
-{
-  conn_data *conn = (conn_data*)lua_newuserdata(L, sizeof(conn_data));
-  luasql_setmeta(L, LUASQL_CONNECTION_SQLITE);
-
-  /* fill in structure */
-  conn->closed = 0;
-  conn->env = LUA_NOREF;
-  conn->auto_commit = 1;
-  conn->sql_conn = sql_conn;
-  conn->cur_counter = 0;
-  lua_pushvalue (L, env);
-  conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
-  return 1;
-}
-
-
-/*
-** Connects to a data source.
-*/
-static int env_connect(lua_State *L)
-{
-  const char *sourcename;
-  sqlite3 *conn;
-  const char *errmsg;
-  int res;
-  getenvironment(L);  /* validate environment */
-  
-  sourcename = luaL_checkstring(L, 2);
-  
-  res = sqlite3_open(sourcename, &conn);
-  if (res != SQLITE_OK)
-    {
-      errmsg = sqlite3_errmsg(conn);
-      lua_pushnil(L);
-      lua_pushliteral(L, LUASQL_PREFIX);
-      lua_pushstring(L, errmsg);
-      lua_concat(L, 2);
-      sqlite3_close(conn);
-      return 2;
-    }
-  
-  if (lua_isnumber(L, 3)) {
-  	sqlite3_busy_timeout(conn, lua_tonumber(L,3));
-  }
-  
-  return create_connection(L, 1, conn);
-}
-
-
-/*
-** Close environment object.
-*/
-static int env_close (lua_State *L)
-{
-  env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
-  luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-  if (env->closed) {
-    lua_pushboolean(L, 0);
-    return 1;
-  }
-
-  env->closed = 1;
-  lua_pushboolean(L, 1);
-  return 1;
-}
-
-
-/*
-** Sets the timeout for a lock in the connection.
-*/
-static int opts_settimeout  (lua_State *L)
-{
-	conn_data *conn = getconnection(L);
-	int milisseconds = luaL_checknumber(L, 2);
-	lua_pushnumber(L, sqlite3_busy_timeout(conn, milisseconds));
-	return 1;
-}
-
-/*
-** Create metatables for each class of object.
-*/
-static void create_metatables (lua_State *L)
-{
-  struct luaL_reg environment_methods[] = {
-    {"__gc", env_close},
-    {"close", env_close},
-    {"connect", env_connect},
-    {NULL, NULL},
-  };
-  struct luaL_reg connection_methods[] = {
-    {"__gc", conn_close},
-    {"close", conn_close},
-    {"escape", conn_escape},
-    {"execute", conn_execute},
-    {"commit", conn_commit},
-    {"rollback", conn_rollback},
-    {"setautocommit", conn_setautocommit},
-    {"getlastautoid", conn_getlastautoid},
-    {NULL, NULL},
-  };
-  struct luaL_reg cursor_methods[] = {
-    {"__gc", cur_close},
-    {"close", cur_close},
-    {"getcolnames", cur_getcolnames},
-    {"getcoltypes", cur_getcoltypes},
-    {"fetch", cur_fetch},
-    {NULL, NULL},
-  };
-  luasql_createmeta(L, LUASQL_ENVIRONMENT_SQLITE, environment_methods);
-  luasql_createmeta(L, LUASQL_CONNECTION_SQLITE, connection_methods);
-  luasql_createmeta(L, LUASQL_CURSOR_SQLITE, cursor_methods);
-  lua_pop (L, 3);
-}
-
-/*
-** Creates an Environment and returns it.
-*/
-static int create_environment (lua_State *L)
-{
-  env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
-  luasql_setmeta(L, LUASQL_ENVIRONMENT_SQLITE);
-
-  /* fill in structure */
-  env->closed = 0;
-  return 1;
-}
-
-
-/*
-** Creates the metatables for the objects and registers the
-** driver open method.
-*/
-LUASQL_API int luaopen_luasql_sqlite3(lua_State *L)
-{
-  struct luaL_reg driver[] = {
-    {"sqlite3", create_environment},
-    {NULL, NULL},
-  };
-  create_metatables (L);
-  luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
-  luasql_set_info (L);
-  return 1;
-}
+/*
+** LuaSQL, SQLite driver
+** Author: Tiago Dionizio, Eduardo Quintao
+** See Copyright Notice in license.html
+
+** $Id: ls_sqlite3.c,v 1.12 2008/06/11 00:26:13 jasonsantos Exp $
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "sqlite3.h"
+
+#include "lua.h"
+#include "lauxlib.h"
+#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
+#include "compat-5.1.h"
+#endif
+
+
+#include "luasql.h"
+
+#define LUASQL_ENVIRONMENT_SQLITE "SQLite3 environment"
+#define LUASQL_CONNECTION_SQLITE "SQLite3 connection"
+#define LUASQL_CURSOR_SQLITE "SQLite3 cursor"
+#define LUASQL_LOCKTIMEOUT "locktimeout"
+
+typedef struct
+{
+  short       closed;
+  int		  locktimeout;
+} env_data;
+
+
+typedef struct
+{
+  short        closed;
+  int          env;                /* reference to environment */
+  short        auto_commit;        /* 0 for manual commit */
+  unsigned int cur_counter;          
+  sqlite3      *sql_conn;
+} conn_data;
+
+
+typedef struct
+{
+  short       closed;
+  int         conn;               /* reference to connection */
+  int         numcols;            /* number of columns */
+  int         colnames, coltypes; /* reference to column information tables */
+  conn_data   *conn_data;         /* reference to connection for cursor */
+  sqlite3_stmt  *sql_vm;
+  char			*modestring;
+} cur_data;
+
+LUASQL_API int luaopen_luasql_sqlite3(lua_State *L);
+
+
+/*
+** Check for valid environment.
+*/
+static env_data *getenvironment(lua_State *L) {
+  env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
+  luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+  luaL_argcheck(L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
+  return env;
+}
+
+
+/*
+** Check for valid connection.
+*/
+static conn_data *getconnection(lua_State *L) {
+  conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_SQLITE);
+  luaL_argcheck(L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+  luaL_argcheck(L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
+  return conn;
+}
+
+
+/*
+** Check for valid cursor.
+*/
+static cur_data *getcursor(lua_State *L) {
+  cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_SQLITE);
+  luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+  luaL_argcheck(L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
+  return cur;
+}
+
+/*
+** Finalizes the vm
+** Return nil + errmsg or nil in case of sucess
+*/
+static int finalize(lua_State *L, cur_data *cur) {
+  const char *errmsg;
+  if (sqlite3_finalize(cur->sql_vm) != SQLITE_OK)
+    {
+      errmsg = sqlite3_errmsg(cur->conn_data->sql_conn);
+      cur->sql_vm = NULL;
+      lua_pushnil(L);
+      lua_pushliteral(L, LUASQL_PREFIX);
+      lua_pushstring(L, errmsg);
+      lua_concat(L, 2);
+      return 2;
+    }
+  cur->sql_vm = NULL;
+  lua_pushnil(L);
+  return 1;
+}
+
+
+static void push_column(lua_State *L, sqlite3_stmt *vm, int column) {
+  switch (sqlite3_column_type(vm, column)) {
+  case SQLITE_INTEGER:
+    lua_pushinteger(L, sqlite3_column_int64(vm, column));
+    break;
+  case SQLITE_FLOAT:
+    lua_pushnumber(L, sqlite3_column_double(vm, column));
+    break;
+  case SQLITE_TEXT:
+    lua_pushlstring(L, sqlite3_column_text(vm, column),
+		    sqlite3_column_bytes(vm, column));
+    break;
+  case SQLITE_BLOB:
+    lua_pushlstring(L, sqlite3_column_blob(vm, column),
+		    sqlite3_column_bytes(vm, column));
+    break;
+  case SQLITE_NULL:
+    lua_pushnil(L);
+    break;
+  default:
+    luaL_error(L, LUASQL_PREFIX"Unrecognized column type");
+    break;
+  }
+}
+
+/*
+** Get another row of the given cursor.
+*/
+static int cur_fetch (lua_State *L) {
+  cur_data *cur = getcursor(L);
+  sqlite3_stmt *vm = cur->sql_vm;
+  int res;
+
+  if (vm == NULL)
+    return 0;
+
+  res = sqlite3_step(vm);
+
+  /* no more results? */
+  if (res == SQLITE_DONE)
+    return finalize(L, cur);
+
+  if (res != SQLITE_ROW)
+    return finalize(L, cur);
+
+  if (lua_istable (L, 2))
+    {
+      int i;
+      const char *opts = luasql_getfetchmodestring( L, cur->modestring );
+
+      if (strchr(opts, 'n') != NULL)
+        {
+	  /* Copy values to numerical indices */
+	  for (i = 0; i < cur->numcols;)
+            {
+	      push_column(L, vm, i);
+	      lua_rawseti(L, 2, ++i);
+	    }
+        }
+      if (strchr(opts, 'a') != NULL)
+        {
+	  /* Copy values to alphanumerical indices */
+	  lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
+
+	  for (i = 0; i < cur->numcols; i++)
+            {
+	      lua_rawgeti(L, -1, i+1);
+	      push_column(L, vm, i);
+	      lua_rawset (L, 2);
+	    }
+        }
+      lua_pushvalue(L, 2);
+      return 1; /* return table */
+    }
+  else
+    {
+      int i;
+      luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
+      for (i = 0; i < cur->numcols; ++i)
+	push_column(L, vm, i);
+      return cur->numcols; /* return #numcols values */
+    }
+}
+
+
+/*
+** Close the cursor on top of the stack.
+** Return 1
+*/
+static int cur_close(lua_State *L)
+{
+  conn_data *conn;
+  cur_data *cur = (cur_data *)luaL_checkudata(L, 1, LUASQL_CURSOR_SQLITE);
+  luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+  if (cur->closed) {
+    lua_pushboolean(L, 0);
+    return 1;
+  }
+
+  /* Nullify structure fields. */
+  cur->closed = 1;
+  sqlite3_finalize(cur->sql_vm);
+  /* Decrement cursor counter on connection object */
+  lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
+  conn = lua_touserdata (L, -1);
+  conn->cur_counter--;
+
+  luaL_unref(L, LUA_REGISTRYINDEX, cur->conn);
+  luaL_unref(L, LUA_REGISTRYINDEX, cur->colnames);
+  luaL_unref(L, LUA_REGISTRYINDEX, cur->coltypes);
+
+  lua_pushboolean(L, 1);
+  return 1;
+}
+
+
+/*
+** Return the list of field names.
+*/
+static int cur_getcolnames(lua_State *L)
+{
+  cur_data *cur = getcursor(L);
+  lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
+  return 1;
+}
+
+
+/*
+** Return the list of field types.
+*/
+static int cur_getcoltypes(lua_State *L)
+{
+  cur_data *cur = getcursor(L);
+  lua_rawgeti(L, LUA_REGISTRYINDEX, cur->coltypes);
+  return 1;
+}
+
+
+/*
+ * Sets the cursor parameters
+ */
+static void cur_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					if( lua_isstring( L, -1 ) )
+						cur->modestring = lua_tostring( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified cursor parameters
+ */
+static int cur_get( lua_State *L ) {
+	if( lua_istable( L, 2 ) ) {
+		lua_newtable(L);
+		int rsp = lua_gettop(L);
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					lua_pushstring( L, LUASQL_MODESTRING );
+					lua_pushstring( L, cur->modestring );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+				cur_data *cur = getcursor(L);
+				lua_pushstring( L, cur->modestring );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Cursor object and push it on top of the stack.
+*/
+/* static int create_cursor(lua_State *L, int conn, sqlite3_stmt *sql_vm,
+   int numcols, const char **row, const char **col_info)*/
+static int create_cursor(lua_State *L, int o, conn_data *conn, 
+			 sqlite3_stmt *sql_vm, int numcols)
+{
+  int i;
+  cur_data *cur = (cur_data*)lua_newuserdata(L, sizeof(cur_data));
+  luasql_setmeta (L, LUASQL_CURSOR_SQLITE);
+
+  /* increment cursor count for the connection creating this cursor */
+  conn->cur_counter++;
+
+  /* fill in structure */
+  cur->closed = 0;
+  cur->conn = LUA_NOREF;
+  cur->numcols = numcols;
+  cur->colnames = LUA_NOREF;
+  cur->coltypes = LUA_NOREF;
+  cur->sql_vm = sql_vm;
+  cur->conn_data = conn;
+  cur->modestring = "n";
+
+  lua_pushvalue(L, o);
+  cur->conn = luaL_ref(L, LUA_REGISTRYINDEX);
+
+  /* create table with column names */
+  lua_newtable(L);
+  for (i = 0; i < numcols;)
+    {
+      lua_pushstring(L, sqlite3_column_name(sql_vm, i));
+      lua_rawseti(L, -2, ++i);
+    }
+  cur->colnames = luaL_ref(L, LUA_REGISTRYINDEX);
+	
+  /* create table with column types */
+  lua_newtable(L);
+  for (i = 0; i < numcols;)
+    {
+      lua_pushstring(L, sqlite3_column_decltype(sql_vm, i));
+      lua_rawseti(L, -2, ++i);
+    }
+  cur->coltypes = luaL_ref(L, LUA_REGISTRYINDEX);
+
+  return 1;
+}
+
+
+/*
+** Close a Connection object.
+*/
+static int conn_close(lua_State *L)
+{
+  conn_data *conn = (conn_data *)luaL_checkudata(L, 1, LUASQL_CONNECTION_SQLITE);
+  luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+  if (conn->closed) 
+    {
+      lua_pushboolean(L, 0);
+      return 1;
+    }
+
+  if (conn->cur_counter > 0)
+    return luaL_error (L, LUASQL_PREFIX"there are open cursors");
+
+  /* Nullify structure fields. */
+  conn->closed = 1;
+  luaL_unref(L, LUA_REGISTRYINDEX, conn->env);
+  sqlite3_close(conn->sql_conn);
+  lua_pushboolean(L, 1);
+  return 1;
+}
+
+static int conn_escape(lua_State *L)
+{
+  const char *from = luaL_checklstring (L, 2, 0);
+  char *escaped = sqlite3_mprintf("%q", from);
+  if (escaped == NULL) 
+    {
+      lua_pushnil(L);
+    } 
+  else
+    {
+      lua_pushstring(L, escaped);        
+      sqlite3_free(escaped);
+    }
+  return 1;
+}
+
+/*
+** Execute an SQL statement.
+** Return a Cursor object if the statement is a query, otherwise
+** return the number of tuples affected by the statement.
+*/
+static int conn_execute(lua_State *L)
+{
+  conn_data *conn = getconnection(L);
+  const char *statement = luaL_checkstring(L, 2);
+  int res;
+  sqlite3_stmt *vm;
+  const char *errmsg;
+  int numcols;
+  const char *tail;
+
+  res = sqlite3_prepare(conn->sql_conn, statement, -1, &vm, &tail);
+  if (res != SQLITE_OK)
+    {
+      errmsg = sqlite3_errmsg(conn->sql_conn);
+      lua_pushnil(L);
+      lua_pushliteral(L, LUASQL_PREFIX);
+      lua_pushstring(L, errmsg);
+      lua_concat(L, 2);
+      return 2;
+    }
+
+  /* process first result to retrive query information and type */
+  res = sqlite3_step(vm);
+  numcols = sqlite3_column_count(vm);
+
+  /* real query? if empty, must have numcols!=0 */
+  if ((res == SQLITE_ROW) || ((res == SQLITE_DONE) && numcols))
+    {
+      sqlite3_reset(vm);
+      return create_cursor(L, 1, conn, vm, numcols);
+    }
+
+  if (res == SQLITE_DONE) /* and numcols==0, INSERT,UPDATE,DELETE statement */
+    {
+      sqlite3_finalize(vm);
+      /* return number of columns changed */
+      lua_pushnumber(L, sqlite3_changes(conn->sql_conn));
+      return 1;
+    }
+
+  /* error */
+  errmsg = sqlite3_errmsg(conn->sql_conn);
+  sqlite3_finalize(vm);
+  lua_pushnil(L);
+  lua_pushliteral(L, LUASQL_PREFIX);
+  lua_pushstring(L, errmsg);
+  lua_concat(L, 2);
+  return 2;
+}
+
+
+/*
+** Commit the current transaction.
+*/
+static int conn_commit(lua_State *L)
+{
+  char *errmsg;
+  conn_data *conn = getconnection(L);
+  int res;
+  const char *sql = "COMMIT";
+
+  if (conn->auto_commit == 0) sql = "COMMIT;BEGIN";
+
+  res = sqlite3_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
+
+  if (res != SQLITE_OK)
+    {
+      lua_pushnil(L);
+      lua_pushliteral(L, LUASQL_PREFIX);
+      lua_pushstring(L, errmsg);
+      sqlite3_free(errmsg);
+      lua_concat(L, 2);
+      return 2;
+    }
+  lua_pushboolean(L, 1);
+  return 1;
+}
+
+
+/*
+** Rollback the current transaction.
+*/
+static int conn_rollback(lua_State *L)
+{
+  char *errmsg;
+  conn_data *conn = getconnection(L);
+  int res;
+  const char *sql = "ROLLBACK";
+
+  if (conn->auto_commit == 0) sql = "ROLLBACK;BEGIN";
+
+  res = sqlite3_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
+  if (res != SQLITE_OK)
+    {
+      lua_pushnil(L);
+      lua_pushliteral(L, LUASQL_PREFIX);
+      lua_pushstring(L, errmsg);
+      sqlite3_free(errmsg);
+      lua_concat(L, 2);
+      return 2;
+    }
+  lua_pushboolean(L, 1);
+  return 1;
+}
+
+static int conn_getlastautoid(lua_State *L)
+{
+  conn_data *conn = getconnection(L);
+  lua_pushnumber(L, sqlite3_last_insert_rowid(conn->sql_conn));
+  return 1;
+}
+
+/*
+** Set "auto commit" property of the connection.
+** If 'true', then rollback current transaction.
+** If 'false', then start a new transaction.
+*/
+static void conn_dosetautocommit(lua_State *L, conn_data *conn, int pos) {
+	if (lua_toboolean(L, pos))
+	{
+		conn->auto_commit = 1;
+        /* undo active transaction - ignore errors */
+	    sqlite3_exec(conn->sql_conn, "ROLLBACK", NULL, NULL, NULL);
+	}
+	else
+	{
+		char *errmsg;
+	    int res;
+	    conn->auto_commit = 0;
+	    res = sqlite3_exec(conn->sql_conn, "BEGIN", NULL, NULL, &errmsg);
+
+	    if (res != SQLITE_OK) {
+	    	lua_pushliteral(L, LUASQL_PREFIX);
+	    	lua_pushstring(L, errmsg);
+	    	sqlite3_free(errmsg);
+	    	lua_concat(L, 2);
+	    	lua_error(L);
+	    }
+	}
+}
+
+
+static int conn_setautocommit(lua_State *L)
+{
+  conn_data *conn = getconnection(L);
+  conn_dosetautocommit(L, conn, 2);
+  lua_pushboolean(L, 1);
+  return 1;
+}
+
+
+/*
+ * Sets the connection parameters
+ */
+static void conn_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					if( lua_isboolean( L, -1 ) )
+						conn_dosetautocommit(L, conn, -1);
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified connection parameters
+ */
+static int conn_get( lua_State *L ) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					lua_pushstring( L, LUASQL_AUTOCOMMIT );
+					lua_pushboolean( L, conn->auto_commit );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+				conn_data *conn = getconnection(L);
+				lua_pushboolean( L, conn->auto_commit );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Connection object and push it on top of the stack.
+*/
+static int create_connection(lua_State *L, int env, sqlite3 *sql_conn)
+{
+  conn_data *conn = (conn_data*)lua_newuserdata(L, sizeof(conn_data));
+  luasql_setmeta(L, LUASQL_CONNECTION_SQLITE);
+
+  /* fill in structure */
+  conn->closed = 0;
+  conn->env = LUA_NOREF;
+  conn->auto_commit = 1;
+  conn->sql_conn = sql_conn;
+  conn->cur_counter = 0;
+  lua_pushvalue (L, env);
+  conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
+  return 1;
+}
+
+
+/*
+** Connects to a data source.
+*/
+static int env_connect(lua_State *L)
+{
+  char *sourcename = NULL;
+  sqlite3 *conn;
+  const char *errmsg;
+  int res;
+  env_data *env = getenvironment(L);  /* validate environment */
+  int time_out = env->locktimeout;
+    
+  if( lua_istable( L, 2 ) ) {
+		lua_pushstring( L, LUASQL_SOURCENAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			sourcename = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+		lua_gettable( L, 2 );
+		
+		if( lua_isnumber( L, -1 ) )
+			time_out = lua_tointeger( L, -1 );
+
+		lua_pop( L, 1 );
+  } else {
+	  sourcename = luaL_checkstring(L, 2);
+
+	  if( lua_isnumber(L, 3) )
+		  time_out = lua_tointeger(L, 3);
+  }
+  
+  res = sqlite3_open(sourcename, &conn);
+  if (res != SQLITE_OK)
+    {
+      errmsg = sqlite3_errmsg(conn);
+      lua_pushnil(L);
+      lua_pushliteral(L, LUASQL_PREFIX);
+      lua_pushstring(L, errmsg);
+      lua_concat(L, 2);
+      sqlite3_close(conn);
+      return 2;
+    }
+  
+  if (time_out > -1) {
+  	sqlite3_busy_timeout(conn, time_out);
+  }
+  
+  return create_connection(L, 1, conn);
+}
+
+
+/*
+** Close environment object.
+*/
+static int env_close (lua_State *L)
+{
+  env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
+  luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+  if (env->closed) {
+    lua_pushboolean(L, 0);
+    return 1;
+  }
+
+  env->closed = 1;
+  lua_pushboolean(L, 1);
+  return 1;
+}
+
+
+/*
+** Sets the timeout for a lock in the connection.
+*/
+static int opts_settimeout  (lua_State *L)
+{
+	conn_data *conn = getconnection(L);
+	int milisseconds = luaL_checknumber(L, 2);
+	lua_pushnumber(L, sqlite3_busy_timeout(conn, milisseconds));
+	return 1;
+}
+
+/*
+ * Sets the environment parameters
+ */
+static void env_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					if( lua_isnumber( L, -1 ) )
+						env->locktimeout = lua_tointeger( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+/*
+ * Retrieve the specified environment parameters
+ */
+static int env_get(lua_State *L) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+					lua_pushinteger( L, env->locktimeout );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+				env_data *env = getenvironment(L);
+				lua_pushinteger( L, env->locktimeout );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create metatables for each class of object.
+*/
+static void create_metatables (lua_State *L)
+{
+  struct luaL_reg environment_methods[] = {
+    {"__gc", env_close},
+    {"close", env_close},
+    {"connect", env_connect},
+    {"get", env_get},
+    {"set", env_set},
+    {NULL, NULL},
+  };
+  struct luaL_reg connection_methods[] = {
+    {"__gc", conn_close},
+    {"close", conn_close},
+    {"escape", conn_escape},
+    {"execute", conn_execute},
+    {"commit", conn_commit},
+    {"rollback", conn_rollback},
+    {"setautocommit", conn_setautocommit},
+    {"getlastautoid", conn_getlastautoid},
+    {"get", conn_get},
+    {"set", conn_set},
+    {NULL, NULL},
+  };
+  struct luaL_reg cursor_methods[] = {
+    {"__gc", cur_close},
+    {"close", cur_close},
+    {"getcolnames", cur_getcolnames},
+    {"getcoltypes", cur_getcoltypes},
+    {"fetch", cur_fetch},
+    {"get", cur_get},
+    {"set", cur_set},
+    {NULL, NULL},
+  };
+  luasql_createmeta(L, LUASQL_ENVIRONMENT_SQLITE, environment_methods);
+  luasql_createmeta(L, LUASQL_CONNECTION_SQLITE, connection_methods);
+  luasql_createmeta(L, LUASQL_CURSOR_SQLITE, cursor_methods);
+  lua_pop (L, 3);
+}
+
+/*
+** Creates an Environment and returns it.
+*/
+static int create_environment (lua_State *L)
+{
+  env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
+  luasql_setmeta(L, LUASQL_ENVIRONMENT_SQLITE);
+
+  /* fill in structure */
+  env->closed = 0;
+  env->locktimeout = 100; 
+  return 1;
+}
+
+
+/*
+** Creates the metatables for the objects and registers the
+** driver open method.
+*/
+LUASQL_API int luaopen_luasql_sqlite3(lua_State *L)
+{
+  struct luaL_reg driver[] = {
+    {"sqlite3", create_environment},
+    {NULL, NULL},
+  };
+  create_metatables (L);
+  luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
+  luasql_set_info (L);
+  return 1;
+}
Index: src/ls_postgres.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/ls_postgres.c,v
retrieving revision 1.10
diff -u -r1.10 ls_postgres.c
--- src/ls_postgres.c	4 May 2008 02:46:17 -0000	1.10
+++ src/ls_postgres.c	2 Aug 2008 00:31:39 -0000
@@ -1,611 +1,870 @@
-/*
-** LuaSQL, PostgreSQL driver
-** Authors: Pedro Rabinovitch, Roberto Ierusalimschy, Carlos Cassino
-** Tomas Guisasola, Eduardo Quintao
-** See Copyright Notice in license.html
-** $Id: ls_postgres.c,v 1.10 2008/05/04 02:46:17 tomas Exp $
-*/
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-#include "libpq-fe.h"
-
-#include "lua.h"
-#include "lauxlib.h"
-#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
-#include "compat-5.1.h"
-#endif
-
-
-#include "luasql.h"
-
-#define LUASQL_ENVIRONMENT_PG "PostgreSQL environment"
-#define LUASQL_CONNECTION_PG "PostgreSQL connection"
-#define LUASQL_CURSOR_PG "PostgreSQL cursor"
-
-typedef struct {
-	short      closed;
-} env_data;
-
-
-typedef struct {
-	short      closed;
-	int        env;                /* reference to environment */
-	int        auto_commit;        /* 0 for manual commit */
-	PGconn    *pg_conn;
-} conn_data;
-
-
-typedef struct {
-	short      closed;
-	int        conn;               /* reference to connection */
-	int        numcols;            /* number of columns */
-	int        colnames, coltypes; /* reference to column information tables */
-	int        curr_tuple;         /* next tuple to be read */
-	PGresult  *pg_res;
-} cur_data;
-
-
-typedef void (*creator) (lua_State *L, cur_data *cur);
-
-
-LUASQL_API int luaopen_luasql_postgres(lua_State *L);
-
-
-/*
-** Check for valid environment.
-*/
-static env_data *getenvironment (lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_PG);
-	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	luaL_argcheck (L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
-	return env;
-}
-
-
-/*
-** Check for valid connection.
-*/
-static conn_data *getconnection (lua_State *L) {
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_PG);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	luaL_argcheck (L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
-	return conn;
-}
-
-
-/*
-** Check for valid cursor.
-*/
-static cur_data *getcursor (lua_State *L) {
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_PG);
-	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	luaL_argcheck (L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
-	return cur;
-}
-
-
-/*
-** Push the value of #i field of #tuple row.
-*/
-static void pushvalue (lua_State *L, PGresult *res, int tuple, int i) {
-	if (PQgetisnull (res, tuple, i-1))
-		lua_pushnil (L);
-	else
-		lua_pushstring (L, PQgetvalue (res, tuple, i-1));
-}
-
-
-/*
-** Closes the cursor and nullify all structure fields.
-*/
-static void cur_nullify (lua_State *L, cur_data *cur) {
-	/* Nullify structure fields. */
-	cur->closed = 1;
-	PQclear(cur->pg_res);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
-}
-
-
-/*
-** Get another row of the given cursor.
-*/
-static int cur_fetch (lua_State *L) {
-	cur_data *cur = getcursor (L);
-	PGresult *res = cur->pg_res;
-	int tuple = cur->curr_tuple;
-
-	if (tuple >= PQntuples(cur->pg_res)) {
-		cur_nullify (L, cur);
-		lua_pushnil(L);  /* no more results */
-		return 1;
-	}
-
-	cur->curr_tuple++;
-	if (lua_istable (L, 2)) {
-		int i;
-		const char *opts = luaL_optstring (L, 3, "n");
-		if (strchr (opts, 'n') != NULL)
-			/* Copy values to numerical indices */
-			for (i = 1; i <= cur->numcols; i++) {
-				pushvalue (L, res, tuple, i);
-				lua_rawseti (L, 2, i);
-			}
-		if (strchr (opts, 'a') != NULL)
-			/* Copy values to alphanumerical indices */
-			for (i = 1; i <= cur->numcols; i++) {
-				lua_pushstring (L, PQfname (res, i-1));
-				pushvalue (L, res, tuple, i);
-				lua_rawset (L, 2);
-			}
-		lua_pushvalue(L, 2);
-		return 1; /* return table */
-	}
-	else {
-		int i;
-		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
-		for (i = 1; i <= cur->numcols; i++)
-			pushvalue (L, res, tuple, i);
-		return cur->numcols; /* return #numcols values */
-	}
-}
-
-
-/*
-** Cursor object collector function
-*/
-static int cur_gc (lua_State *L) {
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_PG);
-	if (cur != NULL && !(cur->closed))
-		cur_nullify (L, cur);
-	return 0;
-}
-
-
-/*
-** Closes the cursor on top of the stack.
-** Returns true in case of success, or false in case the cursor was
-** already closed.
-** Throws an error if the argument is not a cursor.
-*/
-static int cur_close (lua_State *L) {
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_PG);
-	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	if (cur->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-	cur_nullify (L, cur); /* == cur_gc (L); */
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-/*
-** Get the internal database type of the given column.
-*/
-static char *getcolumntype (PGconn *conn, PGresult *result, int i, char *buff) {
-	Oid codigo = PQftype (result, i);
-	char stmt[100];
-	PGresult *res;
-
-	sprintf (stmt, "select typname from pg_type where oid = %d", codigo);
-	res = PQexec(conn, stmt);
-	strcpy (buff, "undefined");
-
-	if (PQresultStatus (res) == PGRES_TUPLES_OK) {
-		if (PQntuples(res) > 0) {
-			char *name = PQgetvalue(res, 0, 0);
-			if (strcmp (name, "bpchar")==0 || strcmp (name, "varchar")==0) {
-				int modifier = PQfmod (result, i) - 4;
-				sprintf (buff, "%.20s (%d)", name, modifier);
-			}
-			else
-				strncpy (buff, name, 20);
-		}
-	}
-	PQclear(res);
-	return buff;
-}
-
-
-/*
-** Creates the list of fields names and pushes it on top of the stack.
-*/
-static void create_colnames (lua_State *L, cur_data *cur) {
-	PGresult *result = cur->pg_res;
-	int i;
-	lua_newtable (L);
-	for (i = 1; i <= cur->numcols; i++) {
-		lua_pushstring (L, PQfname (result, i-1));
-		lua_rawseti (L, -2, i);
-	}
-}
-
-
-/*
-** Creates the list of fields types and pushes it on top of the stack.
-*/
-static void create_coltypes (lua_State *L, cur_data *cur) {
-	PGresult *result = cur->pg_res;
-	conn_data *conn;
-	char typename[100];
-	int i;
-	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
-	if (!lua_isuserdata (L, -1))
-		luaL_error (L, LUASQL_PREFIX"invalid connection");
-	conn = (conn_data *)lua_touserdata (L, -1);
-	lua_newtable (L);
-	for (i = 1; i <= cur->numcols; i++) {
-		lua_pushstring(L, getcolumntype (conn->pg_conn, result, i-1, typename));
-		lua_rawseti (L, -2, i);
-	}
-}
-
-
-/*
-** Pushes a column information table on top of the stack.
-** If the table isn't built yet, call the creator function and stores
-** a reference to it on the cursor structure.
-*/
-static void _pushtable (lua_State *L, cur_data *cur, size_t off, creator func) {
-	int *ref = (int *)((char *)cur + off);
-	if (*ref != LUA_NOREF)
-		lua_rawgeti (L, LUA_REGISTRYINDEX, *ref);
-	else {
-		func (L, cur);
-		/* Stores a reference to it on the cursor structure */
-		lua_pushvalue (L, -1);
-		*ref = luaL_ref (L, LUA_REGISTRYINDEX);
-	}
-}
-#define pushtable(L,c,m,f) (_pushtable(L,c,offsetof(cur_data,m),f))
-
-
-/*
-** Return the list of field names.
-*/
-static int cur_getcolnames (lua_State *L) {
-	pushtable (L, getcursor(L), colnames, create_colnames);
-	return 1;
-}
-
-
-/*
-** Return the list of field types.
-*/
-static int cur_getcoltypes (lua_State *L) {
-	pushtable (L, getcursor(L), coltypes, create_coltypes);
-	return 1;
-}
-
-
-/*
-** Push the number of rows.
-*/
-static int cur_numrows (lua_State *L) {
-	lua_pushnumber (L, PQntuples (getcursor(L)->pg_res));
-	return 1;
-}
-
-
-/*
-** Create a new Cursor object and push it on top of the stack.
-*/
-static int create_cursor (lua_State *L, int conn, PGresult *result) {
-	cur_data *cur = (cur_data *)lua_newuserdata(L, sizeof(cur_data));
-	luasql_setmeta (L, LUASQL_CURSOR_PG);
-
-	/* fill in structure */
-	cur->closed = 0;
-	cur->conn = LUA_NOREF;
-	cur->numcols = PQnfields(result);
-	cur->colnames = LUA_NOREF;
-	cur->coltypes = LUA_NOREF;
-	cur->curr_tuple = 0;
-	cur->pg_res = result;
-	lua_pushvalue (L, conn);
-	cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
-
-	return 1;
-}
-
-
-static void sql_commit(conn_data *conn) {
-	PQclear(PQexec(conn->pg_conn, "COMMIT"));
-}
-
-
-static void sql_begin(conn_data *conn) {
-	PQclear(PQexec(conn->pg_conn, "BEGIN")); 
-}
-
-
-static void sql_rollback(conn_data *conn) {
-	PQclear(PQexec(conn->pg_conn, "ROLLBACK"));
-}
-
-
-/*
-** Connection object collector function
-*/
-static int conn_gc (lua_State *L) {
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_PG);
-	if (conn != NULL && !(conn->closed)) {
-		/* Nullify structure fields. */
-		conn->closed = 1;
-		luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
-		PQfinish (conn->pg_conn);
-	}
-	return 0;
-}
-
-
-/*
-** Closes the connection on top of the stack.
-** Returns true in case of success, or false in case the connection was
-** already closed.
-** Throws an error if the argument is not a connection.
-*/
-static int conn_close (lua_State *L) {
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_PG);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	if (conn->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-	conn_gc (L);
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-/*
-** Escapes a string for use within an SQL statement.
-** Returns a string with the escaped string.
-*/
-static int conn_escape (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	size_t len;
-	const char *from = luaL_checklstring (L, 2, &len);
-	char to[len*sizeof(char)*2+1];
-	int error;
-	len = PQescapeStringConn (conn->pg_conn, to, from, len, &error);
-	if (error == 0) { /* success ! */
-		lua_pushlstring (L, to, len);
-		return 1;
-	} else
-		return luasql_faildirect (L, PQerrorMessage (conn->pg_conn));
-}
-
-
-/*
-** Execute an SQL statement.
-** Return a Cursor object if the statement is a query, otherwise
-** return the number of tuples affected by the statement.
-*/
-static int conn_execute (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	const char *statement = luaL_checkstring (L, 2);
-	PGresult *res = PQexec(conn->pg_conn, statement);
-	if (res && PQresultStatus(res)==PGRES_COMMAND_OK) {
-		/* no tuples returned */
-		lua_pushnumber(L, atof(PQcmdTuples(res)));
-		PQclear (res);
-		return 1;
-	}
-	else if (res && PQresultStatus(res)==PGRES_TUPLES_OK)
-		/* tuples returned */
-		return create_cursor (L, 1, res);
-	else {
-		/* error */
-		PQclear (res);
-		return luasql_faildirect(L, PQerrorMessage(conn->pg_conn));
-	}
-}
-
-
-/*
-** Commit the current transaction.
-*/
-static int conn_commit (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	sql_commit(conn);
-	if (conn->auto_commit == 0) {
-		sql_begin(conn); 
-		lua_pushboolean (L, 1);
-	} else
-		lua_pushboolean (L, 0);
-	return 1;
-}
-
-
-/*
-** Rollback the current transaction.
-*/
-static int conn_rollback (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	sql_rollback(conn);
-	if (conn->auto_commit == 0) {
-		sql_begin(conn); 
-		lua_pushboolean (L, 1);
-	} else
-		lua_pushboolean (L, 0);
-	return 1;
-}
-
-
-/*
-** Set "auto commit" property of the connection.
-** If 'true', then rollback current transaction.
-** If 'false', then start a new transaction.
-*/
-static int conn_setautocommit (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	if (lua_toboolean (L, 2)) {
-		conn->auto_commit = 1;
-		sql_rollback(conn); /* Undo active transaction. */
-	}
-	else {
-		conn->auto_commit = 0;
-		sql_begin(conn);
-	}
-	lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Create a new Connection object and push it on top of the stack.
-*/
-static int create_connection (lua_State *L, int env, PGconn *const pg_conn) {
-	conn_data *conn = (conn_data *)lua_newuserdata(L, sizeof(conn_data));
-	luasql_setmeta (L, LUASQL_CONNECTION_PG);
-
-	/* fill in structure */
-	conn->closed = 0;
-	conn->env = LUA_NOREF;
-	conn->auto_commit = 1;
-	conn->pg_conn = pg_conn;
-	lua_pushvalue (L, env);
-	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
-	return 1;
-}
-
-
-static void notice_processor (void *arg, const char *message) {
-	(void)arg; (void)message;
-	/* arg == NULL */
-}
-
-
-/*
-** Connects to a data source.
-** This driver provides two ways to connect to a data source:
-** (1) giving the connection parameters as a set of pairs separated
-**     by whitespaces in a string (first method parameter)
-** (2) giving one string for each connection parameter, said
-**     datasource, username, password, host and port.
-*/
-static int env_connect (lua_State *L) {
-	const char *sourcename = luaL_checkstring(L, 2);
-	PGconn *conn;
-	getenvironment (L);	/* validate environment */
-	if ((lua_gettop (L) == 2) && (strchr (sourcename, '=') != NULL))
-		conn = PQconnectdb (sourcename);
-	else {
-		const char *username = luaL_optstring(L, 3, NULL);
-		const char *password = luaL_optstring(L, 4, NULL);
-		const char *pghost = luaL_optstring(L, 5, NULL);
-		const char *pgport = luaL_optstring(L, 6, NULL);
-
-		conn = PQsetdbLogin(pghost, pgport, NULL, NULL,
-			sourcename, username, password);
-	}
-
-	if (PQstatus(conn) == CONNECTION_BAD)
-		return luasql_faildirect(L, LUASQL_PREFIX"Error connecting to database.");
-	PQsetNoticeProcessor(conn, notice_processor, NULL);
-	return create_connection(L, 1, conn);
-}
-
-
-/*
-** Environment object collector function.
-*/
-static int env_gc (lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_PG);
-	if (env != NULL && !(env->closed))
-		env->closed = 1;
-	return 0;
-}
-
-
-/*
-** Closes the environment on top of the stack.
-** Returns true in case of success, or false in case the environment was
-** already closed.
-** Throws an error if the argument is not an environment.
-*/
-static int env_close (lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_PG);
-	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	if (env->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-	env_gc (L);
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-
-/*
-** Create metatables for each class of object.
-*/
-static void create_metatables (lua_State *L) {
-	struct luaL_reg environment_methods[] = {
-		{"__gc",    env_gc},
-		{"close",   env_close},
-		{"connect", env_connect},
-		{NULL, NULL},
-	};
-	struct luaL_reg connection_methods[] = {
-		{"__gc",          conn_gc},
-		{"close",         conn_close},
-		{"escape",        conn_escape},
-		{"execute",       conn_execute},
-		{"commit",        conn_commit},
-		{"rollback",      conn_rollback},
-		{"setautocommit", conn_setautocommit},
-		{NULL, NULL},
-	};
-	struct luaL_reg cursor_methods[] = {
-		{"__gc",        cur_gc},
-		{"close",       cur_close},
-		{"getcolnames", cur_getcolnames},
-		{"getcoltypes", cur_getcoltypes},
-		{"fetch",       cur_fetch},
-		{"numrows",     cur_numrows},
-		{NULL, NULL},
-	};
-	luasql_createmeta (L, LUASQL_ENVIRONMENT_PG, environment_methods);
-	luasql_createmeta (L, LUASQL_CONNECTION_PG, connection_methods);
-	luasql_createmeta (L, LUASQL_CURSOR_PG, cursor_methods);
-	lua_pop (L, 3);
-}
-
-/*
-** Creates an Environment and returns it.
-*/
-static int create_environment (lua_State *L) {
-	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
-	luasql_setmeta (L, LUASQL_ENVIRONMENT_PG);
-
-	/* fill in structure */
-	env->closed = 0;
-	return 1;
-}
-
-
-/*
-** Creates the metatables for the objects and registers the
-** driver open method.
-*/
-LUASQL_API int luaopen_luasql_postgres (lua_State *L) {
-	struct luaL_reg driver[] = {
-		{"postgres", create_environment},
-		{NULL, NULL},
-	};
-	create_metatables (L);
-	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
-	luasql_set_info (L);
-	return 1;
-}
+/*
+** LuaSQL, PostgreSQL driver
+** Authors: Pedro Rabinovitch, Roberto Ierusalimschy, Carlos Cassino
+** Tomas Guisasola, Eduardo Quintao
+** See Copyright Notice in license.html
+** $Id: ls_postgres.c,v 1.10 2008/05/04 02:46:17 tomas Exp $
+*/
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "libpq-fe.h"
+
+#include "lua.h"
+#include "lauxlib.h"
+#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
+#include "compat-5.1.h"
+#endif
+
+
+#include "luasql.h"
+
+#define LUASQL_ENVIRONMENT_PG "PostgreSQL environment"
+#define LUASQL_CONNECTION_PG "PostgreSQL connection"
+#define LUASQL_CURSOR_PG "PostgreSQL cursor"
+
+typedef struct {
+	short      closed;
+} env_data;
+
+
+typedef struct {
+	short      closed;
+	int        env;                /* reference to environment */
+	int        auto_commit;        /* 0 for manual commit */
+	PGconn    *pg_conn;
+} conn_data;
+
+
+typedef struct {
+	short      closed;
+	int        conn;               /* reference to connection */
+	int        numcols;            /* number of columns */
+	int        colnames, coltypes; /* reference to column information tables */
+	int        curr_tuple;         /* next tuple to be read */
+	PGresult  *pg_res;
+	char	  *modestring;
+} cur_data;
+
+
+typedef void (*creator) (lua_State *L, cur_data *cur);
+
+
+LUASQL_API int luaopen_luasql_postgres(lua_State *L);
+
+
+/*
+** Check for valid environment.
+*/
+static env_data *getenvironment (lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_PG);
+	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	luaL_argcheck (L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
+	return env;
+}
+
+
+/*
+** Check for valid connection.
+*/
+static conn_data *getconnection (lua_State *L) {
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_PG);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	luaL_argcheck (L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
+	return conn;
+}
+
+
+/*
+** Check for valid cursor.
+*/
+static cur_data *getcursor (lua_State *L) {
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_PG);
+	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	luaL_argcheck (L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
+	return cur;
+}
+
+
+/*
+** Push the value of #i field of #tuple row.
+*/
+static void pushvalue (lua_State *L, PGresult *res, int tuple, int i) {
+	if (PQgetisnull (res, tuple, i-1))
+		lua_pushnil (L);
+	else
+		lua_pushstring (L, PQgetvalue (res, tuple, i-1));
+}
+
+
+/*
+** Closes the cursor and nullify all structure fields.
+*/
+static void cur_nullify (lua_State *L, cur_data *cur) {
+	/* Nullify structure fields. */
+	cur->closed = 1;
+	PQclear(cur->pg_res);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
+}
+
+
+/*
+** Get another row of the given cursor.
+*/
+static int cur_fetch (lua_State *L) {
+	cur_data *cur = getcursor (L);
+	PGresult *res = cur->pg_res;
+	int tuple = cur->curr_tuple;
+
+	if (tuple >= PQntuples(cur->pg_res)) {
+		cur_nullify (L, cur);
+		lua_pushnil(L);  /* no more results */
+		return 1;
+	}
+
+	cur->curr_tuple++;
+	if (lua_istable (L, 2)) {
+		int i;
+	    const char *opts = luasql_getfetchmodestring( L, cur->modestring );
+		if (strchr (opts, 'n') != NULL)
+			/* Copy values to numerical indices */
+			for (i = 1; i <= cur->numcols; i++) {
+				pushvalue (L, res, tuple, i);
+				lua_rawseti (L, 2, i);
+			}
+		if (strchr (opts, 'a') != NULL)
+			/* Copy values to alphanumerical indices */
+			for (i = 1; i <= cur->numcols; i++) {
+				lua_pushstring (L, PQfname (res, i-1));
+				pushvalue (L, res, tuple, i);
+				lua_rawset (L, 2);
+			}
+		lua_pushvalue(L, 2);
+		return 1; /* return table */
+	}
+	else {
+		int i;
+		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
+		for (i = 1; i <= cur->numcols; i++)
+			pushvalue (L, res, tuple, i);
+		return cur->numcols; /* return #numcols values */
+	}
+}
+
+
+/*
+** Cursor object collector function
+*/
+static int cur_gc (lua_State *L) {
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_PG);
+	if (cur != NULL && !(cur->closed))
+		cur_nullify (L, cur);
+	return 0;
+}
+
+
+/*
+** Closes the cursor on top of the stack.
+** Returns true in case of success, or false in case the cursor was
+** already closed.
+** Throws an error if the argument is not a cursor.
+*/
+static int cur_close (lua_State *L) {
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_PG);
+	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	if (cur->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+	cur_nullify (L, cur); /* == cur_gc (L); */
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+** Get the internal database type of the given column.
+*/
+static char *getcolumntype (PGconn *conn, PGresult *result, int i, char *buff) {
+	Oid codigo = PQftype (result, i);
+	char stmt[100];
+	PGresult *res;
+
+	sprintf (stmt, "select typname from pg_type where oid = %d", codigo);
+	res = PQexec(conn, stmt);
+	strcpy (buff, "undefined");
+
+	if (PQresultStatus (res) == PGRES_TUPLES_OK) {
+		if (PQntuples(res) > 0) {
+			char *name = PQgetvalue(res, 0, 0);
+			if (strcmp (name, "bpchar")==0 || strcmp (name, "varchar")==0) {
+				int modifier = PQfmod (result, i) - 4;
+				sprintf (buff, "%.20s (%d)", name, modifier);
+			}
+			else
+				strncpy (buff, name, 20);
+		}
+	}
+	PQclear(res);
+	return buff;
+}
+
+
+/*
+** Creates the list of fields names and pushes it on top of the stack.
+*/
+static void create_colnames (lua_State *L, cur_data *cur) {
+	PGresult *result = cur->pg_res;
+	int i;
+	lua_newtable (L);
+	for (i = 1; i <= cur->numcols; i++) {
+		lua_pushstring (L, PQfname (result, i-1));
+		lua_rawseti (L, -2, i);
+	}
+}
+
+
+/*
+** Creates the list of fields types and pushes it on top of the stack.
+*/
+static void create_coltypes (lua_State *L, cur_data *cur) {
+	PGresult *result = cur->pg_res;
+	conn_data *conn;
+	char typename[100];
+	int i;
+	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
+	if (!lua_isuserdata (L, -1))
+		luaL_error (L, LUASQL_PREFIX"invalid connection");
+	conn = (conn_data *)lua_touserdata (L, -1);
+	lua_newtable (L);
+	for (i = 1; i <= cur->numcols; i++) {
+		lua_pushstring(L, getcolumntype (conn->pg_conn, result, i-1, typename));
+		lua_rawseti (L, -2, i);
+	}
+}
+
+
+/*
+** Pushes a column information table on top of the stack.
+** If the table isn't built yet, call the creator function and stores
+** a reference to it on the cursor structure.
+*/
+static void _pushtable (lua_State *L, cur_data *cur, size_t off, creator func) {
+	int *ref = (int *)((char *)cur + off);
+	if (*ref != LUA_NOREF)
+		lua_rawgeti (L, LUA_REGISTRYINDEX, *ref);
+	else {
+		func (L, cur);
+		/* Stores a reference to it on the cursor structure */
+		lua_pushvalue (L, -1);
+		*ref = luaL_ref (L, LUA_REGISTRYINDEX);
+	}
+}
+#define pushtable(L,c,m,f) (_pushtable(L,c,offsetof(cur_data,m),f))
+
+
+/*
+** Return the list of field names.
+*/
+static int cur_getcolnames (lua_State *L) {
+	pushtable (L, getcursor(L), colnames, create_colnames);
+	return 1;
+}
+
+
+/*
+** Return the list of field types.
+*/
+static int cur_getcoltypes (lua_State *L) {
+	pushtable (L, getcursor(L), coltypes, create_coltypes);
+	return 1;
+}
+
+
+/*
+** Push the number of rows.
+*/
+static int cur_numrows (lua_State *L) {
+	lua_pushnumber (L, PQntuples (getcursor(L)->pg_res));
+	return 1;
+}
+
+
+/*
+ * Sets the cursor parameters
+ */
+static void cur_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					if( lua_isstring( L, -1 ) )
+						cur->modestring = lua_tostring( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified cursor parameters
+ */
+static int cur_get( lua_State *L ) {
+	if( lua_istable( L, 2 ) ) {
+		lua_newtable(L);
+		int rsp = lua_gettop(L);
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					lua_pushstring( L, LUASQL_MODESTRING );
+					lua_pushstring( L, cur->modestring );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+				cur_data *cur = getcursor(L);
+				lua_pushstring( L, cur->modestring );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Cursor object and push it on top of the stack.
+*/
+static int create_cursor (lua_State *L, int conn, PGresult *result) {
+	cur_data *cur = (cur_data *)lua_newuserdata(L, sizeof(cur_data));
+	luasql_setmeta (L, LUASQL_CURSOR_PG);
+
+	/* fill in structure */
+	cur->closed = 0;
+	cur->conn = LUA_NOREF;
+	cur->numcols = PQnfields(result);
+	cur->colnames = LUA_NOREF;
+	cur->coltypes = LUA_NOREF;
+	cur->curr_tuple = 0;
+	cur->pg_res = result;
+	lua_pushvalue (L, conn);
+	cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
+
+	return 1;
+}
+
+
+static void sql_commit(conn_data *conn) {
+	PQclear(PQexec(conn->pg_conn, "COMMIT"));
+}
+
+
+static void sql_begin(conn_data *conn) {
+	PQclear(PQexec(conn->pg_conn, "BEGIN")); 
+}
+
+
+static void sql_rollback(conn_data *conn) {
+	PQclear(PQexec(conn->pg_conn, "ROLLBACK"));
+}
+
+
+/*
+** Connection object collector function
+*/
+static int conn_gc (lua_State *L) {
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_PG);
+	if (conn != NULL && !(conn->closed)) {
+		/* Nullify structure fields. */
+		conn->closed = 1;
+		luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
+		PQfinish (conn->pg_conn);
+	}
+	return 0;
+}
+
+
+/*
+** Closes the connection on top of the stack.
+** Returns true in case of success, or false in case the connection was
+** already closed.
+** Throws an error if the argument is not a connection.
+*/
+static int conn_close (lua_State *L) {
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_PG);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	if (conn->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+	conn_gc (L);
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+** Escapes a string for use within an SQL statement.
+** Returns a string with the escaped string.
+*/
+static int conn_escape (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	size_t len;
+	const char *from = luaL_checklstring (L, 2, &len);
+	char to[len*sizeof(char)*2+1];
+	int error;
+	len = PQescapeStringConn (conn->pg_conn, to, from, len, &error);
+	if (error == 0) { /* success ! */
+		lua_pushlstring (L, to, len);
+		return 1;
+	} else
+		return luasql_faildirect (L, PQerrorMessage (conn->pg_conn));
+}
+
+
+/*
+** Execute an SQL statement.
+** Return a Cursor object if the statement is a query, otherwise
+** return the number of tuples affected by the statement.
+*/
+static int conn_execute (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	const char *statement = luaL_checkstring (L, 2);
+	PGresult *res = PQexec(conn->pg_conn, statement);
+	if (res && PQresultStatus(res)==PGRES_COMMAND_OK) {
+		/* no tuples returned */
+		lua_pushnumber(L, atof(PQcmdTuples(res)));
+		PQclear (res);
+		return 1;
+	}
+	else if (res && PQresultStatus(res)==PGRES_TUPLES_OK)
+		/* tuples returned */
+		return create_cursor (L, 1, res);
+	else {
+		/* error */
+		PQclear (res);
+		return luasql_faildirect(L, PQerrorMessage(conn->pg_conn));
+	}
+}
+
+
+/*
+** Commit the current transaction.
+*/
+static int conn_commit (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	sql_commit(conn);
+	if (conn->auto_commit == 0) {
+		sql_begin(conn); 
+		lua_pushboolean (L, 1);
+	} else
+		lua_pushboolean (L, 0);
+	return 1;
+}
+
+
+/*
+** Rollback the current transaction.
+*/
+static int conn_rollback (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	sql_rollback(conn);
+	if (conn->auto_commit == 0) {
+		sql_begin(conn); 
+		lua_pushboolean (L, 1);
+	} else
+		lua_pushboolean (L, 0);
+	return 1;
+}
+
+
+/*
+** Set "auto commit" property of the connection.
+** If 'true', then rollback current transaction.
+** If 'false', then start a new transaction.
+*/
+static void conn_dosetautocommit(lua_State *L, conn_data *conn, int pos){
+	if (lua_toboolean (L, pos)) {
+		conn->auto_commit = 1;
+		sql_rollback(conn); /* Undo active transaction. */
+	}
+	else {
+		conn->auto_commit = 0;
+		sql_begin(conn);
+	}
+}
+
+static int conn_setautocommit (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	conn_dosetautocommit(L, conn, 2);
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+ * Sets the connection parameters
+ */
+static void conn_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					if( lua_isboolean( L, -1 ) )
+						conn_dosetautocommit(L, conn, -1);
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified connection parameters
+ */
+static int conn_get( lua_State *L ) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					lua_pushstring( L, LUASQL_AUTOCOMMIT );
+					lua_pushboolean( L, conn->auto_commit );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+				conn_data *conn = getconnection(L);
+				lua_pushboolean( L, conn->auto_commit );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Connection object and push it on top of the stack.
+*/
+static int create_connection (lua_State *L, int env, PGconn *const pg_conn) {
+	conn_data *conn = (conn_data *)lua_newuserdata(L, sizeof(conn_data));
+	luasql_setmeta (L, LUASQL_CONNECTION_PG);
+
+	/* fill in structure */
+	conn->closed = 0;
+	conn->env = LUA_NOREF;
+	conn->auto_commit = 1;
+	conn->pg_conn = pg_conn;
+	lua_pushvalue (L, env);
+	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
+	return 1;
+}
+
+
+static void notice_processor (void *arg, const char *message) {
+	(void)arg; (void)message;
+	/* arg == NULL */
+}
+
+
+/*
+** Connects to a data source.
+** This driver provides two ways to connect to a data source:
+** (1) giving the connection parameters as a set of pairs separated
+**     by whitespaces in a string (first method parameter)
+** (2) giving one string for each connection parameter, said
+**     datasource, username, password, host and port.
+*/
+static int env_connect (lua_State *L) {
+	char *sourcename;
+	char *username;
+	char *password;
+	char *pghost;
+	char *pgport;
+	PGconn *conn;
+	getenvironment (L);	/* validate environment */
+
+	if( lua_istable( L, 2 ) ) {
+		lua_pushstring( L, LUASQL_SOURCENAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			sourcename = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );		
+
+		if( strchr(sourcename, '=') != NULL )
+			conn = PQconnectdb (sourcename);
+		else {
+			lua_pushstring( L, LUASQL_USERNAME );
+			lua_gettable( L, 2 );
+			
+			if( lua_isstring( L, -1 ) )
+				username = lua_tostring( L, -1 );
+
+			lua_pop( L, 1 );
+			lua_pushstring( L, LUASQL_PASSWORD );
+			lua_gettable( L, 2 );
+			
+			if( lua_isstring( L, -1 ) )
+				password = lua_tostring( L, -1 );
+
+			lua_pop( L, 1 );
+			lua_pushstring( L, LUASQL_HOSTNAME );
+			lua_gettable( L, 2 );
+			
+			if( lua_isstring( L, -1 ) )
+				pghost = lua_tostring( L, -1 );
+
+			lua_pop( L, 1 );
+			lua_pushstring( L, LUASQL_PORT );
+			lua_gettable( L, 2 );
+			
+			if( lua_isnumber( L, -1 ) )
+				pgport = lua_tointeger( L, -1 );
+
+			lua_pop( L, 1 );
+			conn = PQsetdbLogin(pghost, pgport, NULL, NULL,
+						sourcename, username, password);
+		}
+	} else {
+		sourcename = luaL_checkstring(L, 2);
+
+		if( (lua_gettop (L) == 2) && (strchr(sourcename, '=') != NULL) )
+			conn = PQconnectdb (sourcename);
+		else {
+			username = luaL_optstring(L, 3, NULL);
+			password = luaL_optstring(L, 4, NULL);
+			pghost = luaL_optstring(L, 5, NULL);
+			pgport = luaL_optstring(L, 6, NULL);
+
+			conn = PQsetdbLogin(pghost, pgport, NULL, NULL,
+						sourcename, username, password);
+		}
+	}
+
+	if (PQstatus(conn) == CONNECTION_BAD)
+		return luasql_faildirect(L, LUASQL_PREFIX"Error connecting to database.");
+	PQsetNoticeProcessor(conn, notice_processor, NULL);
+	return create_connection(L, 1, conn);
+}
+
+
+/*
+** Environment object collector function.
+*/
+static int env_gc (lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_PG);
+	if (env != NULL && !(env->closed))
+		env->closed = 1;
+	return 0;
+}
+
+
+/*
+** Closes the environment on top of the stack.
+** Returns true in case of success, or false in case the environment was
+** already closed.
+** Throws an error if the argument is not an environment.
+*/
+static int env_close (lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_PG);
+	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	if (env->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+	env_gc (L);
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+ * Sets the environment parameters
+ */
+static void env_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					if( lua_isnumber( L, -1 ) )
+						env->locktimeout = lua_tointeger( L, -1 );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+/*
+ * Retrieve the specified environment parameters
+ */
+static int env_get(lua_State *L) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+					lua_pushinteger( L, env->locktimeout );
+					lua_settable( L, rsp );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+/*
+			if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+				env_data *env = getenvironment(L);
+				lua_pushinteger( L, env->locktimeout );
+			} else */
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create metatables for each class of object.
+*/
+static void create_metatables (lua_State *L) {
+	struct luaL_reg environment_methods[] = {
+		{"__gc",    env_gc},
+		{"close",   env_close},
+		{"connect", env_connect},
+	    {"get", 	env_get},
+	    {"set", 	env_set},
+		{NULL, NULL},
+	};
+	struct luaL_reg connection_methods[] = {
+		{"__gc",          conn_gc},
+		{"close",         conn_close},
+		{"escape",        conn_escape},
+		{"execute",       conn_execute},
+		{"commit",        conn_commit},
+		{"rollback",      conn_rollback},
+		{"setautocommit", conn_setautocommit},
+	    {"get", 		  conn_get},
+	    {"set", 		  conn_set},
+		{NULL, NULL},
+	};
+	struct luaL_reg cursor_methods[] = {
+		{"__gc",        cur_gc},
+		{"close",       cur_close},
+		{"getcolnames", cur_getcolnames},
+		{"getcoltypes", cur_getcoltypes},
+		{"fetch",       cur_fetch},
+		{"numrows",     cur_numrows},
+	    {"get", 		cur_get},
+	    {"set", 		cur_set},
+		{NULL, NULL},
+	};
+	luasql_createmeta (L, LUASQL_ENVIRONMENT_PG, environment_methods);
+	luasql_createmeta (L, LUASQL_CONNECTION_PG, connection_methods);
+	luasql_createmeta (L, LUASQL_CURSOR_PG, cursor_methods);
+	luasql_createdefaultoptions( L );
+	lua_pop (L, 3);
+}
+
+/*
+** Creates an Environment and returns it.
+*/
+static int create_environment (lua_State *L) {
+	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
+	luasql_setmeta (L, LUASQL_ENVIRONMENT_PG);
+
+	/* fill in structure */
+	env->closed = 0;
+	return 1;
+}
+
+
+/*
+** Creates the metatables for the objects and registers the
+** driver open method.
+*/
+LUASQL_API int luaopen_luasql_postgres (lua_State *L) {
+	struct luaL_reg driver[] = {
+		{"postgres", create_environment},
+		{NULL, NULL},
+	};
+	create_metatables (L);
+	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
+	luasql_set_info (L);
+	return 1;
+}
Index: src/ls_oci8.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/ls_oci8.c,v
retrieving revision 1.29
diff -u -r1.29 ls_oci8.c
--- src/ls_oci8.c	4 May 2008 02:46:17 -0000	1.29
+++ src/ls_oci8.c	2 Aug 2008 00:31:38 -0000
@@ -1,861 +1,1100 @@
-/*
-** LuaSQL, Oracle driver
-** Authors: Tomas Guisasola, Leonardo Godinho
-** See Copyright Notice in license.html
-** $Id: ls_oci8.c,v 1.29 2008/05/04 02:46:17 tomas Exp $
-*/
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-#include "oci.h"
-#include "oratypes.h"
-#include "ociapr.h"
-#include "ocidem.h"
-
-#include "lua.h"
-#include "lauxlib.h"
-#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
-#include "compat-5.1.h"
-#endif
-
-
-#include "luasql.h"
-
-#define LUASQL_ENVIRONMENT_OCI8 "Oracle environment"
-#define LUASQL_CONNECTION_OCI8 "Oracle connection"
-#define LUASQL_CURSOR_OCI8 "Oracle cursor"
-
-
-typedef struct {
-	short         closed;
-	int           conn_counter;
-	OCIEnv       *envhp;
-	OCIError     *errhp; /* !!! */
-} env_data;
-
-
-typedef struct {
-	short         closed;
-	short         loggedon;
-	short         auto_commit;        /* 0 for manual commit */
-	int           cur_counter;
-	int           env;                /* reference to environment */
-	OCISvcCtx    *svchp;              /* service handle */
-	OCIError     *errhp; /* !!! */
-} conn_data;
-
-
-typedef union {
-	int     i;
-	char   *s;
-	double  d;
-} column_value;
-
-
-typedef struct {
-	ub2           type;    /* database type */
-	text         *name;    /* column name */
-	ub4           namelen; /* column name length */
-	ub2           max;     /* maximum size */
-	sb2           null;    /* is null? */
-	OCIDefine    *define;  /* define handle */
-	column_value  val;
-} column_data;
-
-
-typedef struct {
-	short         closed;
-	int           conn;               /* reference to connection */
-	int           numcols;            /* number of columns */
-	int           colnames, coltypes; /* reference to column info tables */
-	int           curr_tuple;         /* next tuple to be read */
-	char         *text;               /* text of SQL statement */
-	OCIStmt      *stmthp;             /* statement handle */
-	OCIError     *errhp; /* !!! */
-	column_data  *cols;               /* array of columns */
-} cur_data;
-
-
-int checkerr (lua_State *L, sword status, OCIError *errhp);
-#define ASSERT(L,exp,err) {sword s = exp; if (s) return checkerr (L, s, err);}
-LUASQL_API int luaopen_luasql_oci8 (lua_State *L);
-
-
-/*
-** Check for valid environment.
-*/
-static env_data *getenvironment (lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_OCI8);
-	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	luaL_argcheck (L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
-	return env;
-}
-
-
-/*
-** Check for valid connection.
-*/
-static conn_data *getconnection (lua_State *L) {
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_OCI8);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	luaL_argcheck (L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
-	return conn;
-}
-
-
-/*
-** Check for valid cursor.
-*/
-static cur_data *getcursor (lua_State *L) {
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_OCI8);
-	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	luaL_argcheck (L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
-	return cur;
-}
-
-
-/*
-** Push nil plus an error message.
-*/
-int checkerr (lua_State *L, sword status, OCIError *errhp) {
-	lua_pushnil (L);
-	switch (status) {
-		case OCI_SUCCESS:
-			lua_pushnil (L); /* !!!!!!!!!!!!! */
-			break;
-		case OCI_SUCCESS_WITH_INFO:
-			lua_pushstring (L, LUASQL_PREFIX"Sucesso com info!");
-			break;
-		case OCI_NEED_DATA:
-			lua_pushstring (L, LUASQL_PREFIX"OCI_NEED_DATA");
-			break;
-		case OCI_NO_DATA:
-			lua_pushstring (L, LUASQL_PREFIX"OCI_NODATA");
-			break;
-		case OCI_ERROR: {
-			text errbuf[512];
-			sb4 errcode = 0;
-			OCIErrorGet (errhp, (ub4) 1, (text *) NULL, &errcode,
-				errbuf, (ub4) sizeof (errbuf), OCI_HTYPE_ERROR);
-			lua_pushstring (L, LUASQL_PREFIX);
-			lua_pushstring (L, errbuf);
-			lua_concat (L, 2);
-			break;
-		}
-		case OCI_INVALID_HANDLE:
-			lua_pushstring (L, LUASQL_PREFIX"OCI_INVALID_HANDLE");
-			break;
-		case OCI_STILL_EXECUTING:
-			lua_pushstring (L, LUASQL_PREFIX"OCI_STILL_EXECUTE");
-			break;
-		case OCI_CONTINUE:
-			lua_pushstring (L, LUASQL_PREFIX"OCI_CONTINUE");
-			break;
-	}
-	return 2;
-}
-
-
-/*
-** Copy the column name to the column structure and convert it to lower case.
-*/
-static void copy_column_name (column_data *col, text *name) {
-	unsigned int i;
-	col->name = (text *)malloc (col->namelen);
-	memcpy (col->name, name, col->namelen);
-	for (i = 0; i < col->namelen; i++)
-		col->name[i] = tolower (col->name[i]);
-}
-
-
-/*
-** Alloc buffers for column values.
-*/
-static int alloc_column_buffer (lua_State *L, cur_data *cur, int i) {
-	/* column index ranges from 1 to numcols */
-	/* C array index ranges from 0 to numcols-1 */
-	column_data *col = &(cur->cols[i-1]);
-	OCIParam *param;
-	text *name;
-
-	ASSERT (L, OCIParamGet (cur->stmthp, OCI_HTYPE_STMT, cur->errhp,
-		(dvoid **)&param, i), cur->errhp);
-	ASSERT (L, OCIAttrGet (param, OCI_DTYPE_PARAM,
-		(dvoid *)&(name), (ub4 *)&(col->namelen),
-		OCI_ATTR_NAME, cur->errhp), cur->errhp);
-	copy_column_name (col, name);
-	ASSERT (L, OCIAttrGet (param, OCI_DTYPE_PARAM,
-		(dvoid *)&(col->type), (ub4 *)0, OCI_ATTR_DATA_TYPE,
-		cur->errhp), cur->errhp);
-
-	switch (col->type) {
-		case SQLT_CHR:
-		case SQLT_STR:
-		case SQLT_VCS:
-		case SQLT_AFC:
-		case SQLT_AVC:
-			ASSERT (L, OCIAttrGet (param, OCI_DTYPE_PARAM,
-				(dvoid *)&(col->max), 0, OCI_ATTR_DATA_SIZE,
-				cur->errhp), cur->errhp);
-			col->val.s = calloc (col->max + 1, sizeof(col->val.s));
-			ASSERT (L, OCIDefineByPos (cur->stmthp, &(col->define),
-				cur->errhp, (ub4)i, col->val.s, col->max+1,
-				SQLT_STR /*col->type*/, (dvoid *)&(col->null), (ub2 *)0,
-				(ub2 *)0, (ub4) OCI_DEFAULT), cur->errhp);
-			break;
-		case SQLT_NUM:
-		case SQLT_FLT:
-		case SQLT_INT:
-		/* case SQLT_UIN: */
-			ASSERT (L, OCIDefineByPos (cur->stmthp, &(col->define),
-				cur->errhp, (ub4)i, &(col->val.d), sizeof(col->val.d),
-				SQLT_FLT, (dvoid *)&(col->null), (ub2 *)0,
-				(ub2 *)0, (ub4) OCI_DEFAULT), cur->errhp);
-			break;
-		case SQLT_CLOB: {
-			env_data *env;
-			conn_data *conn;
-			lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
-			conn = (conn_data *)lua_touserdata (L, -1);
-			lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
-			env = (env_data *)lua_touserdata (L, -1);
-			lua_pop (L, 2);
-			ASSERT (L, OCIDescriptorAlloc (env->envhp, (dvoid *)&(col->val.s),
-				OCI_DTYPE_LOB, (size_t)0, (dvoid **)0), cur->errhp);
-			ASSERT (L, OCIDefineByPos (cur->stmthp, &(col->define),
-				cur->errhp, (ub4)i, &(col->val.s), (sb4)sizeof(dvoid *),
-				SQLT_CLOB, (dvoid *)&(col->null), (ub2 *)0, (ub2 *)0,
-				OCI_DEFAULT), cur->errhp);
-			break;
-		}
-		default:
-			luaL_error (L, LUASQL_PREFIX"invalid type %d #%d", col->type, i);
-			break;
-	}
-	return 0;
-}
-
-
-/*
-** Deallocate column buffers.
-*/
-static int free_column_buffers (lua_State *L, cur_data *cur, int i) {
-	/* column index ranges from 1 to numcols */
-	/* C array index ranges from 0 to numcols-1 */
-	column_data *col = &(cur->cols[i-1]);
-	free (col->name);
-	switch (col->type) {
-		case SQLT_INT:
-		case SQLT_FLT:
-		case SQLT_NUM:
-			break;
-		case SQLT_CHR:
-		case SQLT_STR:
-		case SQLT_VCS:
-		case SQLT_AFC:
-		case SQLT_AVC:
-			free(col->val.s);
-			break;
-		case SQLT_CLOB:
-			ASSERT (L, OCIDescriptorFree (col->val.s,
-				OCI_DTYPE_LOB), cur->errhp);
-			break;
-		default:
-			luaL_error (L, LUASQL_PREFIX"unknown type");
-			/*printf("free_buffers(): Unknow Type: %d count: %d\n",cols.item[count].type, count );*/
-			break;
-	}
-    return 0;
-}
-
-
-/*
-** Push a value on top of the stack.
-*/
-static int pushvalue (lua_State *L, cur_data *cur, int i) {
-	/* column index ranges from 1 to numcols */
-	/* C array index ranges from 0 to numcols-1 */
-	column_data *col = &(cur->cols[i-1]);
-	if (col->null) {
-		/* Oracle NULL => Lua nil */
-		lua_pushnil (L);
-		return 1;
-	}
-	switch (col->type) {
-		case SQLT_NUM:
-		case SQLT_INT:
-		case SQLT_FLT:
-			lua_pushnumber (L, col->val.d);
-			break;
-		case SQLT_CHR:
-		case SQLT_STR:
-		case SQLT_VCS:
-		case SQLT_AFC:
-		case SQLT_AVC:
-			lua_pushstring (L, (char *)(col->val.s));
-			break;
-		case SQLT_CLOB: {
-			ub4 lob_len;
-			conn_data *conn;
-			env_data *env;
-			lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
-			conn = lua_touserdata (L, -1);
-			lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
-			env = lua_touserdata (L, -1);
-			lua_pop (L, 2);
-			ASSERT (L, OCILobGetLength (conn->svchp, cur->errhp,
-				(OCILobLocator *)col->val.s, &lob_len), cur->errhp);
-			if (lob_len > 0) {
-				char *lob_buffer=malloc(lob_len);
-				ub4 amount = lob_len;
-
-				ASSERT(L, OCILobRead(conn->svchp, cur->errhp,
-					(OCILobLocator *) col->val.s, &amount, (ub4) 1,
-					(dvoid *) lob_buffer, (ub4) lob_len, (dvoid *)0,
-					(sb4 (*) (dvoid *, CONST dvoid *, ub4, ub1)) 0,
-					(ub2) 0, (ub1) SQLCS_IMPLICIT), cur->errhp);
-				lua_pushlstring (L, lob_buffer, amount);
-				free(lob_buffer);
-			} else {
-				lua_pushstring (L, "");
-			}
-			break;
-		}
-		default:
-			luaL_error (L, LUASQL_PREFIX"unexpected error");
-	}
-	return 1;
-}
-
-
-/*
-** Get another row of the given cursor.
-*/
-static int cur_fetch (lua_State *L) {
-	cur_data *cur = getcursor (L);
-	sword status = OCIStmtFetch (cur->stmthp, cur->errhp, 1,
-		OCI_FETCH_NEXT, OCI_DEFAULT);
-
-	if (status == OCI_NO_DATA) {
-		/* No more rows */
-		lua_pushnil (L);
-		return 1;
-	} else if (status != OCI_SUCCESS) {
-		/* Error */
-		return checkerr (L, status, cur->errhp);
-	}
-
-	if (lua_istable (L, 2)) {
-		int i;
-		const char *opts = luaL_optstring (L, 3, "n");
-		if (strchr (opts, 'n') != NULL)
-			/* Copy values to numerical indices */
-			for (i = 1; i <= cur->numcols; i++) {
-				int ret = pushvalue (L, cur, i);
-				if (ret != 1)
-					return ret;
-				lua_rawseti (L, 2, i);
-			}
-		if (strchr (opts, 'a') != NULL)
-			/* Copy values to alphanumerical indices */
-			for (i = 1; i <= cur->numcols; i++) {
-				column_data *col = &(cur->cols[i-1]);
-				int ret;
-				lua_pushlstring (L, col->name, col->namelen);
-				if ((ret = pushvalue (L, cur, i)) != 1)
-					return ret;
-				lua_rawset (L, 2);
-			}
-		lua_pushvalue(L, 2);
-		return 1; /* return table */
-	}
-	else {
-		int i;
-		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
-		for (i = 1; i <= cur->numcols; i++) {
-			int ret = pushvalue (L, cur, i);
-			if (ret != 1)
-				return ret;
-		}
-		return cur->numcols; /* return #numcols values */
-	}
-}
-
-
-/*
-** Close the cursor on top of the stack.
-** Return 1
-*/
-static int cur_close (lua_State *L) {
-	int i;
-	conn_data *conn;
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_OCI8);
-	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	if (cur->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-
-	/* Deallocate buffers. */
-	for (i = 1; i <= cur->numcols; i++) {
-		int ret = free_column_buffers (L, cur, i);
-		if (ret)
-			return ret;
-	}
-	free (cur->cols);
-	free (cur->text);
-
-	/* Nullify structure fields. */
-	cur->closed = 1;
-	if (cur->stmthp)
-		OCIHandleFree ((dvoid *)cur->stmthp, OCI_HTYPE_STMT);
-	if (cur->errhp)
-		OCIHandleFree ((dvoid *)cur->errhp, OCI_HTYPE_ERROR);
-	/* Decrement cursor counter on connection object */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
-	conn = lua_touserdata (L, -1);
-	conn->cur_counter--;
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
-
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-/*
-** Return the list of field names as a table on top of the stack.
-*/
-static int cur_getcolnames (lua_State *L) {
-	cur_data *cur = getcursor (L);
-	if (cur->colnames != LUA_NOREF)
-		lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);
-	else {
-		int i;
-		lua_newtable (L);
-		for (i = 1; i <= cur->numcols; i++) {
-			column_data *col = &(cur->cols[i-1]);
-			lua_pushlstring (L, col->name, col->namelen);
-			lua_rawseti (L, -2, i);
-		}
-		lua_pushvalue (L, -1);
-		cur->colnames = luaL_ref (L, LUA_REGISTRYINDEX);
-	}
-	return 1;
-}
-
-
-/*
-**
-*/
-static char *getcolumntype (column_data *col) {
-	switch (col->type) {
-		case SQLT_CHR:
-		case SQLT_STR:
-		case SQLT_VCS:
-		case SQLT_AFC:
-		case SQLT_AVC:
-			return "string";
-		case SQLT_NUM:
-		case SQLT_FLT:
-		case SQLT_INT:
-		/* case SQLT_UIN: */
-			return "number";
-		case SQLT_CLOB:
-			return "string";
-		default:
-			return "";
-	}
-}
-
-
-/*
-** Return the list of field types as a table on top of the stack.
-*/
-static int cur_getcoltypes (lua_State *L) {
-	cur_data *cur = getcursor (L);
-	if (cur->coltypes != LUA_NOREF)
-		lua_rawgeti (L, LUA_REGISTRYINDEX, cur->coltypes);
-	else {
-		int i;
-		lua_newtable (L);
-		for (i = 1; i <= cur->numcols; i++) {
-			column_data *col = &(cur->cols[i-1]);
-			lua_pushnumber (L, i);
-			lua_pushstring (L, getcolumntype (col));
-			lua_rawset (L, -3);
-		}
-		lua_pushvalue (L, -1);
-		cur->coltypes = luaL_ref (L, LUA_REGISTRYINDEX);
-	}
-	return 1;
-}
-
-
-/*
-** Push the number of rows.
-*/
-static int cur_numrows (lua_State *L) {
-	int n;
-	cur_data *cur = getcursor (L);
-	ASSERT (L, OCIAttrGet ((dvoid *) cur->stmthp, OCI_HTYPE_STMT, (dvoid *)&n,
-		(ub4)0, OCI_ATTR_NUM_ROWS, cur->errhp), cur->errhp);
-	lua_pushnumber (L, n);
-	return 1;
-}
-
-
-/*
-** Close a Connection object.
-*/
-static int conn_close (lua_State *L) {
-	env_data *env;
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_OCI8);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	if (conn->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-	if (conn->cur_counter > 0)
-		return luaL_error (L, LUASQL_PREFIX"there are open cursors");
-
-	/* Nullify structure fields. */
-	conn->closed = 1;
-	if (conn->svchp) {
-		if (conn->loggedon)
-			OCILogoff (conn->svchp, conn->errhp);
-		else
-			OCIHandleFree ((dvoid *)conn->svchp, OCI_HTYPE_SVCCTX);
-	}
-	if (conn->errhp)
-		OCIHandleFree ((dvoid *)conn->errhp, OCI_HTYPE_ERROR);
-	/* Decrement connection counter on environment object */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
-	env = lua_touserdata (L, -1);
-	env->conn_counter--;
-	luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
-
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-/*
-** Create a new Cursor object and push it on top of the stack.
-*/
-static int create_cursor (lua_State *L, int o, conn_data *conn, OCIStmt *stmt, const char *text) {
-	int i;
-	env_data *env;
-	cur_data *cur = (cur_data *)lua_newuserdata(L, sizeof(cur_data));
-	luasql_setmeta (L, LUASQL_CURSOR_OCI8);
-
-	conn->cur_counter++;
-	/* fill in structure */
-	cur->closed = 0;
-	cur->numcols = 0;
-	cur->colnames = LUA_NOREF;
-	cur->coltypes = LUA_NOREF;
-	cur->curr_tuple = 0;
-	cur->stmthp = stmt;
-	cur->errhp = NULL;
-	cur->cols = NULL;
-	cur->text = strdup (text);
-	lua_pushvalue (L, o);
-	cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
-
-	/* error handler */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
-	env = lua_touserdata (L, -1);
-	lua_pop (L, 1);
-	ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
-		(dvoid **) &(cur->errhp), (ub4) OCI_HTYPE_ERROR, (size_t) 0,
-		(dvoid **) 0), conn->errhp);
-	/* get number of columns */
-	ASSERT (L, OCIAttrGet ((dvoid *)stmt, (ub4)OCI_HTYPE_STMT,
-		(dvoid *)&cur->numcols, (ub4 *)0, (ub4)OCI_ATTR_PARAM_COUNT,
-		cur->errhp), cur->errhp);
-	cur->cols = (column_data *)malloc (sizeof(column_data) * cur->numcols);
-	/* define output variables */
-	/* Oracle and Lua column indices ranges from 1 to numcols */
-	/* C array indices ranges from 0 to numcols-1 */
-	for (i = 1; i <= cur->numcols; i++) {
-		int ret = alloc_column_buffer (L, cur, i);
-		if (ret)
-			return ret;
-	}
-
-	return 1;
-}
-
-
-/*
-** Execute an SQL statement.
-** Return a Cursor object if the statement is a query, otherwise
-** return the number of tuples affected by the statement.
-*/
-static int conn_execute (lua_State *L) {
-	env_data *env;
-	conn_data *conn = getconnection (L);
-	const char *statement = luaL_checkstring (L, 2);
-	sword status;
-	ub4 prefetch = 0;
-	ub4 iters;
-	ub4 mode;
-	ub2 type;
-	OCIStmt *stmthp;
-
-	/* get environment */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
-	if (!lua_isuserdata (L, -1))
-		luaL_error(L,LUASQL_PREFIX"invalid environment in connection!");
-	env = (env_data *)lua_touserdata (L, -1);
-	/* statement handle */
-	ASSERT (L, OCIHandleAlloc ((dvoid *)env->envhp, (dvoid **)&stmthp,
-		OCI_HTYPE_STMT, (size_t)0, (dvoid **)0), conn->errhp);
-	ASSERT (L, OCIAttrSet ((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT,
-		(dvoid *)&prefetch, (ub4)0, (ub4)OCI_ATTR_PREFETCH_ROWS,
-		conn->errhp), conn->errhp);
-	ASSERT (L, OCIStmtPrepare (stmthp, conn->errhp, (text *)statement,
-		(ub4) strlen(statement), (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT),
-		conn->errhp);
-	/* statement type */
-	ASSERT (L, OCIAttrGet ((dvoid *)stmthp, (ub4) OCI_HTYPE_STMT,
-		(dvoid *)&type, (ub4 *)0, (ub4)OCI_ATTR_STMT_TYPE, conn->errhp),
-		conn->errhp);
-	if (type == OCI_STMT_SELECT)
-		iters = 0;
-	else
-		iters = 1;
-	if (conn->auto_commit)
-		mode = OCI_COMMIT_ON_SUCCESS;
-	else
-		mode = OCI_DEFAULT;
-	/* execute statement */
-	status = OCIStmtExecute (conn->svchp, stmthp, conn->errhp, iters,
-		(ub4)0, (CONST OCISnapshot *)NULL, (OCISnapshot *)NULL, mode);
-	if (status && (status != OCI_NO_DATA)) {
-		OCIHandleFree ((dvoid *)stmthp, OCI_HTYPE_STMT);
-		return checkerr (L, status, conn->errhp);
-	}
-	if (type == OCI_STMT_SELECT) {
-		/* create cursor */
-		return create_cursor (L, 1, conn, stmthp, statement);
-	} else {
-		/* return number of rows */
-		int rows_affected;
-		ASSERT (L, OCIAttrGet ((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT,
-			(dvoid *)&rows_affected, (ub4 *)0,
-			(ub4)OCI_ATTR_ROW_COUNT, conn->errhp), conn->errhp);
-		OCIHandleFree ((dvoid *)stmthp, OCI_HTYPE_STMT);
-		lua_pushnumber (L, rows_affected);
-		return 1;
-	}
-}
-
-
-/*
-** Commit the current transaction.
-*/
-static int conn_commit (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	ASSERT (L, OCITransCommit (conn->svchp, conn->errhp, OCI_DEFAULT),
-		conn->errhp);
-/*
-	if (conn->auto_commit == 0) 
-		ASSERT (L, OCITransStart (conn->svchp, conn->errhp...
-*/
-	return 0;
-}
-
-
-/*
-** Rollback the current transaction.
-*/
-static int conn_rollback (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	ASSERT (L, OCITransRollback (conn->svchp, conn->errhp, OCI_DEFAULT),
-		conn->errhp);
-/*
-	if (conn->auto_commit == 0) 
-		sql_begin(conn); 
-*/
-	return 0;
-}
-
-
-/*
-** Set "auto commit" property of the connection.
-** If 'true', then rollback current transaction.
-** If 'false', then start a new transaction.
-*/
-static int conn_setautocommit (lua_State *L) {
-	conn_data *conn = getconnection (L);
-	if (lua_toboolean (L, 2)) {
-		conn->auto_commit = 1;
-		/* Undo active transaction. */
-		ASSERT (L, OCITransRollback (conn->svchp, conn->errhp,
-			OCI_DEFAULT), conn->errhp);
-	}
-	else {
-		conn->auto_commit = 0;
-		/* sql_begin(conn);*/
-	}
-	lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Connects to a data source.
-*/
-static int env_connect (lua_State *L) {
-	env_data *env = getenvironment (L);
-	const char *sourcename = luaL_checkstring(L, 2);
-	const char *username = luaL_optstring(L, 3, NULL);
-	const char *password = luaL_optstring(L, 4, NULL);
-	/* Sizes of strings */
-	size_t snlen = strlen(sourcename);
-	size_t userlen = (username) ? strlen(username) : 0;
-	size_t passlen = (password) ? strlen(password) : 0;
-	/* Alloc connection object */
-	conn_data *conn = (conn_data *)lua_newuserdata(L, sizeof(conn_data));
-
-	/* fill in structure */
-	luasql_setmeta (L, LUASQL_CONNECTION_OCI8);
-	conn->env = LUA_NOREF;
-	conn->closed = 1;
-	conn->auto_commit = 1;
-	conn->cur_counter = 0;
-	conn->loggedon = 0;
-	conn->svchp = NULL;
-	conn->errhp = NULL;
-	lua_pushvalue (L, 1);
-	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
-
-	/* error handler */
-	ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
-		(dvoid **) &(conn->errhp), /* !!! */
-		(ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0), env->errhp);
-	/* service handler */
-	/*ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
-		(dvoid **) &(conn->svchp),
-		(ub4) OCI_HTYPE_SVCCTX, (size_t) 0, (dvoid **) 0), conn->errhp);
-*/
-	/* login */
-	ASSERT (L, OCILogon(env->envhp, conn->errhp, &(conn->svchp),
-		(CONST text*)username, userlen,
-		(CONST text*)password, passlen,
-		(CONST text*)sourcename, snlen), conn->errhp);
-	conn->closed = 0;
-	env->conn_counter++;
-	conn->loggedon = 1;
-
-	return 1;
-}
-
-
-/*
-** Close environment object.
-*/
-static int env_close (lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_OCI8);
-	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	if (env->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-	if (env->conn_counter > 0)
-		return luaL_error (L, LUASQL_PREFIX"there are open connections");
-
-	env->closed = 1;
-	/* desalocar: env->errhp e env->envhp */
-	if (env->envhp)
-		OCIHandleFree ((dvoid *)env->envhp, OCI_HTYPE_ENV);
-	if (env->errhp)
-		OCIHandleFree ((dvoid *)env->errhp, OCI_HTYPE_ERROR);
-	lua_pushboolean (L, 1);
-	return 1;
-}
-
-
-/*
-** Creates an Environment and returns it.
-*/
-static int create_environment (lua_State *L) {
-	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
-	luasql_setmeta (L, LUASQL_ENVIRONMENT_OCI8);
-	/* fill in structure */
-	env->closed = 0;
-	env->conn_counter = 0;
-	env->envhp = NULL;
-	env->errhp = NULL;
-/* maybe OCI_SHARED and OCI_THREADED ??? */
-	if (OCIEnvCreate ( &(env->envhp), (ub4)OCI_DEFAULT, (dvoid *)0,
-			(dvoid * (*)(dvoid *, size_t)) 0,
-			(dvoid * (*)(dvoid *, dvoid *, size_t)) 0,
-			(void (*)(dvoid *, dvoid *)) 0,
-			(size_t) 0,
-			(dvoid **) 0))
-		luasql_faildirect (L, LUASQL_PREFIX"couldn't create environment");
-	/* error handler */
-	ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
-		(dvoid **) &(env->errhp), /* !!! */
-		(ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0), env->errhp);
-	return 1;
-}
-
-
-/*
-** Create metatables for each class of object.
-*/
-static void create_metatables (lua_State *L) {
-	struct luaL_reg environment_methods[] = {
-		{"__gc", env_close},
-		{"close", env_close},
-		{"connect", env_connect},
-		{NULL, NULL},
-	};
-	struct luaL_reg connection_methods[] = {
-		{"__gc", conn_close},
-		{"close", conn_close},
-		{"execute", conn_execute},
-		{"commit", conn_commit},
-		{"rollback", conn_rollback},
-		{"setautocommit", conn_setautocommit},
-		{NULL, NULL},
-	};
-	struct luaL_reg cursor_methods[] = {
-		{"__gc", cur_close},
-		{"close", cur_close},
-		{"getcolnames", cur_getcolnames},
-		{"getcoltypes", cur_getcoltypes},
-		{"fetch", cur_fetch},
-		{"numrows", cur_numrows},
-		{NULL, NULL},
-	};
-	luasql_createmeta (L, LUASQL_ENVIRONMENT_OCI8, environment_methods);
-	luasql_createmeta (L, LUASQL_CONNECTION_OCI8, connection_methods);
-	luasql_createmeta (L, LUASQL_CURSOR_OCI8, cursor_methods);
-	lua_pop (L, 3);
-}
-
-
-/*
-** Creates the metatables for the objects and registers the
-** driver open method.
-*/
-LUASQL_API int luaopen_luasql_oci8 (lua_State *L) {
-	struct luaL_reg driver[] = {
-		{"oci8", create_environment},
-		{NULL, NULL},
-	};
-	create_metatables (L);
-	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
-	luasql_set_info (L);
-	return 1;
-}
+/*
+** LuaSQL, Oracle driver
+** Authors: Tomas Guisasola, Leonardo Godinho
+** See Copyright Notice in license.html
+** $Id: ls_oci8.c,v 1.29 2008/05/04 02:46:17 tomas Exp $
+*/
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "oci.h"
+#include "oratypes.h"
+#include "ociapr.h"
+#include "ocidem.h"
+
+#include "lua.h"
+#include "lauxlib.h"
+#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
+#include "compat-5.1.h"
+#endif
+
+
+#include "luasql.h"
+
+#define LUASQL_ENVIRONMENT_OCI8 "Oracle environment"
+#define LUASQL_CONNECTION_OCI8 "Oracle connection"
+#define LUASQL_CURSOR_OCI8 "Oracle cursor"
+
+
+typedef struct {
+	short         closed;
+	int           conn_counter;
+	OCIEnv       *envhp;
+	OCIError     *errhp; /* !!! */
+} env_data;
+
+
+typedef struct {
+	short         closed;
+	short         loggedon;
+	short         auto_commit;        /* 0 for manual commit */
+	int           cur_counter;
+	int           env;                /* reference to environment */
+	OCISvcCtx    *svchp;              /* service handle */
+	OCIError     *errhp; /* !!! */
+} conn_data;
+
+
+typedef union {
+	int     i;
+	char   *s;
+	double  d;
+} column_value;
+
+
+typedef struct {
+	ub2           type;    /* database type */
+	text         *name;    /* column name */
+	ub4           namelen; /* column name length */
+	ub2           max;     /* maximum size */
+	sb2           null;    /* is null? */
+	OCIDefine    *define;  /* define handle */
+	column_value  val;
+} column_data;
+
+
+typedef struct {
+	short         closed;
+	int           conn;               /* reference to connection */
+	int           numcols;            /* number of columns */
+	int           colnames, coltypes; /* reference to column info tables */
+	int           curr_tuple;         /* next tuple to be read */
+	char         *text;               /* text of SQL statement */
+	OCIStmt      *stmthp;             /* statement handle */
+	OCIError     *errhp; /* !!! */
+	column_data  *cols;               /* array of columns */
+	char		 *modestring;
+} cur_data;
+
+
+int checkerr (lua_State *L, sword status, OCIError *errhp);
+#define ASSERT(L,exp,err) {sword s = exp; if (s) return checkerr (L, s, err);}
+LUASQL_API int luaopen_luasql_oci8 (lua_State *L);
+
+
+/*
+** Check for valid environment.
+*/
+static env_data *getenvironment (lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_OCI8);
+	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	luaL_argcheck (L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
+	return env;
+}
+
+
+/*
+** Check for valid connection.
+*/
+static conn_data *getconnection (lua_State *L) {
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_OCI8);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	luaL_argcheck (L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
+	return conn;
+}
+
+
+/*
+** Check for valid cursor.
+*/
+static cur_data *getcursor (lua_State *L) {
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_OCI8);
+	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	luaL_argcheck (L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
+	return cur;
+}
+
+
+/*
+** Push nil plus an error message.
+*/
+int checkerr (lua_State *L, sword status, OCIError *errhp) {
+	lua_pushnil (L);
+	switch (status) {
+		case OCI_SUCCESS:
+			lua_pushnil (L); /* !!!!!!!!!!!!! */
+			break;
+		case OCI_SUCCESS_WITH_INFO:
+			lua_pushstring (L, LUASQL_PREFIX"Sucesso com info!");
+			break;
+		case OCI_NEED_DATA:
+			lua_pushstring (L, LUASQL_PREFIX"OCI_NEED_DATA");
+			break;
+		case OCI_NO_DATA:
+			lua_pushstring (L, LUASQL_PREFIX"OCI_NODATA");
+			break;
+		case OCI_ERROR: {
+			text errbuf[512];
+			sb4 errcode = 0;
+			OCIErrorGet (errhp, (ub4) 1, (text *) NULL, &errcode,
+				errbuf, (ub4) sizeof (errbuf), OCI_HTYPE_ERROR);
+			lua_pushstring (L, LUASQL_PREFIX);
+			lua_pushstring (L, errbuf);
+			lua_concat (L, 2);
+			break;
+		}
+		case OCI_INVALID_HANDLE:
+			lua_pushstring (L, LUASQL_PREFIX"OCI_INVALID_HANDLE");
+			break;
+		case OCI_STILL_EXECUTING:
+			lua_pushstring (L, LUASQL_PREFIX"OCI_STILL_EXECUTE");
+			break;
+		case OCI_CONTINUE:
+			lua_pushstring (L, LUASQL_PREFIX"OCI_CONTINUE");
+			break;
+	}
+	return 2;
+}
+
+
+/*
+** Copy the column name to the column structure and convert it to lower case.
+*/
+static void copy_column_name (column_data *col, text *name) {
+	unsigned int i;
+	col->name = (text *)malloc (col->namelen);
+	memcpy (col->name, name, col->namelen);
+	for (i = 0; i < col->namelen; i++)
+		col->name[i] = tolower (col->name[i]);
+}
+
+
+/*
+** Alloc buffers for column values.
+*/
+static int alloc_column_buffer (lua_State *L, cur_data *cur, int i) {
+	/* column index ranges from 1 to numcols */
+	/* C array index ranges from 0 to numcols-1 */
+	column_data *col = &(cur->cols[i-1]);
+	OCIParam *param;
+	text *name;
+
+	ASSERT (L, OCIParamGet (cur->stmthp, OCI_HTYPE_STMT, cur->errhp,
+		(dvoid **)&param, i), cur->errhp);
+	ASSERT (L, OCIAttrGet (param, OCI_DTYPE_PARAM,
+		(dvoid *)&(name), (ub4 *)&(col->namelen),
+		OCI_ATTR_NAME, cur->errhp), cur->errhp);
+	copy_column_name (col, name);
+	ASSERT (L, OCIAttrGet (param, OCI_DTYPE_PARAM,
+		(dvoid *)&(col->type), (ub4 *)0, OCI_ATTR_DATA_TYPE,
+		cur->errhp), cur->errhp);
+
+	switch (col->type) {
+		case SQLT_CHR:
+		case SQLT_STR:
+		case SQLT_VCS:
+		case SQLT_AFC:
+		case SQLT_AVC:
+			ASSERT (L, OCIAttrGet (param, OCI_DTYPE_PARAM,
+				(dvoid *)&(col->max), 0, OCI_ATTR_DATA_SIZE,
+				cur->errhp), cur->errhp);
+			col->val.s = calloc (col->max + 1, sizeof(col->val.s));
+			ASSERT (L, OCIDefineByPos (cur->stmthp, &(col->define),
+				cur->errhp, (ub4)i, col->val.s, col->max+1,
+				SQLT_STR /*col->type*/, (dvoid *)&(col->null), (ub2 *)0,
+				(ub2 *)0, (ub4) OCI_DEFAULT), cur->errhp);
+			break;
+		case SQLT_NUM:
+		case SQLT_FLT:
+		case SQLT_INT:
+		/* case SQLT_UIN: */
+			ASSERT (L, OCIDefineByPos (cur->stmthp, &(col->define),
+				cur->errhp, (ub4)i, &(col->val.d), sizeof(col->val.d),
+				SQLT_FLT, (dvoid *)&(col->null), (ub2 *)0,
+				(ub2 *)0, (ub4) OCI_DEFAULT), cur->errhp);
+			break;
+		case SQLT_CLOB: {
+			env_data *env;
+			conn_data *conn;
+			lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
+			conn = (conn_data *)lua_touserdata (L, -1);
+			lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
+			env = (env_data *)lua_touserdata (L, -1);
+			lua_pop (L, 2);
+			ASSERT (L, OCIDescriptorAlloc (env->envhp, (dvoid *)&(col->val.s),
+				OCI_DTYPE_LOB, (size_t)0, (dvoid **)0), cur->errhp);
+			ASSERT (L, OCIDefineByPos (cur->stmthp, &(col->define),
+				cur->errhp, (ub4)i, &(col->val.s), (sb4)sizeof(dvoid *),
+				SQLT_CLOB, (dvoid *)&(col->null), (ub2 *)0, (ub2 *)0,
+				OCI_DEFAULT), cur->errhp);
+			break;
+		}
+		default:
+			luaL_error (L, LUASQL_PREFIX"invalid type %d #%d", col->type, i);
+			break;
+	}
+	return 0;
+}
+
+
+/*
+** Deallocate column buffers.
+*/
+static int free_column_buffers (lua_State *L, cur_data *cur, int i) {
+	/* column index ranges from 1 to numcols */
+	/* C array index ranges from 0 to numcols-1 */
+	column_data *col = &(cur->cols[i-1]);
+	free (col->name);
+	switch (col->type) {
+		case SQLT_INT:
+		case SQLT_FLT:
+		case SQLT_NUM:
+			break;
+		case SQLT_CHR:
+		case SQLT_STR:
+		case SQLT_VCS:
+		case SQLT_AFC:
+		case SQLT_AVC:
+			free(col->val.s);
+			break;
+		case SQLT_CLOB:
+			ASSERT (L, OCIDescriptorFree (col->val.s,
+				OCI_DTYPE_LOB), cur->errhp);
+			break;
+		default:
+			luaL_error (L, LUASQL_PREFIX"unknown type");
+			/*printf("free_buffers(): Unknow Type: %d count: %d\n",cols.item[count].type, count );*/
+			break;
+	}
+    return 0;
+}
+
+
+/*
+** Push a value on top of the stack.
+*/
+static int pushvalue (lua_State *L, cur_data *cur, int i) {
+	/* column index ranges from 1 to numcols */
+	/* C array index ranges from 0 to numcols-1 */
+	column_data *col = &(cur->cols[i-1]);
+	if (col->null) {
+		/* Oracle NULL => Lua nil */
+		lua_pushnil (L);
+		return 1;
+	}
+	switch (col->type) {
+		case SQLT_NUM:
+		case SQLT_INT:
+		case SQLT_FLT:
+			lua_pushnumber (L, col->val.d);
+			break;
+		case SQLT_CHR:
+		case SQLT_STR:
+		case SQLT_VCS:
+		case SQLT_AFC:
+		case SQLT_AVC:
+			lua_pushstring (L, (char *)(col->val.s));
+			break;
+		case SQLT_CLOB: {
+			ub4 lob_len;
+			conn_data *conn;
+			env_data *env;
+			lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
+			conn = lua_touserdata (L, -1);
+			lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
+			env = lua_touserdata (L, -1);
+			lua_pop (L, 2);
+			ASSERT (L, OCILobGetLength (conn->svchp, cur->errhp,
+				(OCILobLocator *)col->val.s, &lob_len), cur->errhp);
+			if (lob_len > 0) {
+				char *lob_buffer=malloc(lob_len);
+				ub4 amount = lob_len;
+
+				ASSERT(L, OCILobRead(conn->svchp, cur->errhp,
+					(OCILobLocator *) col->val.s, &amount, (ub4) 1,
+					(dvoid *) lob_buffer, (ub4) lob_len, (dvoid *)0,
+					(sb4 (*) (dvoid *, CONST dvoid *, ub4, ub1)) 0,
+					(ub2) 0, (ub1) SQLCS_IMPLICIT), cur->errhp);
+				lua_pushlstring (L, lob_buffer, amount);
+				free(lob_buffer);
+			} else {
+				lua_pushstring (L, "");
+			}
+			break;
+		}
+		default:
+			luaL_error (L, LUASQL_PREFIX"unexpected error");
+	}
+	return 1;
+}
+
+
+/*
+** Get another row of the given cursor.
+*/
+static int cur_fetch (lua_State *L) {
+	cur_data *cur = getcursor (L);
+	sword status = OCIStmtFetch (cur->stmthp, cur->errhp, 1,
+		OCI_FETCH_NEXT, OCI_DEFAULT);
+
+	if (status == OCI_NO_DATA) {
+		/* No more rows */
+		lua_pushnil (L);
+		return 1;
+	} else if (status != OCI_SUCCESS) {
+		/* Error */
+		return checkerr (L, status, cur->errhp);
+	}
+
+	if (lua_istable (L, 2)) {
+		int i;
+		const char *opts = luaL_optstring (L, 3, "n");
+		if (strchr (opts, 'n') != NULL)
+			/* Copy values to numerical indices */
+			for (i = 1; i <= cur->numcols; i++) {
+				int ret = pushvalue (L, cur, i);
+				if (ret != 1)
+					return ret;
+				lua_rawseti (L, 2, i);
+			}
+		if (strchr (opts, 'a') != NULL)
+			/* Copy values to alphanumerical indices */
+			for (i = 1; i <= cur->numcols; i++) {
+				column_data *col = &(cur->cols[i-1]);
+				int ret;
+				lua_pushlstring (L, col->name, col->namelen);
+				if ((ret = pushvalue (L, cur, i)) != 1)
+					return ret;
+				lua_rawset (L, 2);
+			}
+		lua_pushvalue(L, 2);
+		return 1; /* return table */
+	}
+	else {
+		int i;
+		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
+		for (i = 1; i <= cur->numcols; i++) {
+			int ret = pushvalue (L, cur, i);
+			if (ret != 1)
+				return ret;
+		}
+		return cur->numcols; /* return #numcols values */
+	}
+}
+
+
+/*
+** Close the cursor on top of the stack.
+** Return 1
+*/
+static int cur_close (lua_State *L) {
+	int i;
+	conn_data *conn;
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_OCI8);
+	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	if (cur->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+
+	/* Deallocate buffers. */
+	for (i = 1; i <= cur->numcols; i++) {
+		int ret = free_column_buffers (L, cur, i);
+		if (ret)
+			return ret;
+	}
+	free (cur->cols);
+	free (cur->text);
+
+	/* Nullify structure fields. */
+	cur->closed = 1;
+	if (cur->stmthp)
+		OCIHandleFree ((dvoid *)cur->stmthp, OCI_HTYPE_STMT);
+	if (cur->errhp)
+		OCIHandleFree ((dvoid *)cur->errhp, OCI_HTYPE_ERROR);
+	/* Decrement cursor counter on connection object */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
+	conn = lua_touserdata (L, -1);
+	conn->cur_counter--;
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
+
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+** Return the list of field names as a table on top of the stack.
+*/
+static int cur_getcolnames (lua_State *L) {
+	cur_data *cur = getcursor (L);
+	if (cur->colnames != LUA_NOREF)
+		lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);
+	else {
+		int i;
+		lua_newtable (L);
+		for (i = 1; i <= cur->numcols; i++) {
+			column_data *col = &(cur->cols[i-1]);
+			lua_pushlstring (L, col->name, col->namelen);
+			lua_rawseti (L, -2, i);
+		}
+		lua_pushvalue (L, -1);
+		cur->colnames = luaL_ref (L, LUA_REGISTRYINDEX);
+	}
+	return 1;
+}
+
+
+/*
+**
+*/
+static char *getcolumntype (column_data *col) {
+	switch (col->type) {
+		case SQLT_CHR:
+		case SQLT_STR:
+		case SQLT_VCS:
+		case SQLT_AFC:
+		case SQLT_AVC:
+			return "string";
+		case SQLT_NUM:
+		case SQLT_FLT:
+		case SQLT_INT:
+		/* case SQLT_UIN: */
+			return "number";
+		case SQLT_CLOB:
+			return "string";
+		default:
+			return "";
+	}
+}
+
+
+/*
+** Return the list of field types as a table on top of the stack.
+*/
+static int cur_getcoltypes (lua_State *L) {
+	cur_data *cur = getcursor (L);
+	if (cur->coltypes != LUA_NOREF)
+		lua_rawgeti (L, LUA_REGISTRYINDEX, cur->coltypes);
+	else {
+		int i;
+		lua_newtable (L);
+		for (i = 1; i <= cur->numcols; i++) {
+			column_data *col = &(cur->cols[i-1]);
+			lua_pushnumber (L, i);
+			lua_pushstring (L, getcolumntype (col));
+			lua_rawset (L, -3);
+		}
+		lua_pushvalue (L, -1);
+		cur->coltypes = luaL_ref (L, LUA_REGISTRYINDEX);
+	}
+	return 1;
+}
+
+
+/*
+** Push the number of rows.
+*/
+static int cur_numrows (lua_State *L) {
+	int n;
+	cur_data *cur = getcursor (L);
+	ASSERT (L, OCIAttrGet ((dvoid *) cur->stmthp, OCI_HTYPE_STMT, (dvoid *)&n,
+		(ub4)0, OCI_ATTR_NUM_ROWS, cur->errhp), cur->errhp);
+	lua_pushnumber (L, n);
+	return 1;
+}
+
+
+/*
+ * Sets the cursor parameters
+ */
+static void cur_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					if( lua_isstring( L, -1 ) )
+						cur->modestring = lua_tostring( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified cursor parameters
+ */
+static int cur_get( lua_State *L ) {
+	if( lua_istable( L, 2 ) ) {
+		lua_newtable(L);
+		int rsp = lua_gettop(L);
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					lua_pushstring( L, LUASQL_MODESTRING );
+					lua_pushstring( L, cur->modestring );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+				cur_data *cur = getcursor(L);
+				lua_pushstring( L, cur->modestring );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Close a Connection object.
+*/
+static int conn_close (lua_State *L) {
+	env_data *env;
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_OCI8);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	if (conn->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+	if (conn->cur_counter > 0)
+		return luaL_error (L, LUASQL_PREFIX"there are open cursors");
+
+	/* Nullify structure fields. */
+	conn->closed = 1;
+	if (conn->svchp) {
+		if (conn->loggedon)
+			OCILogoff (conn->svchp, conn->errhp);
+		else
+			OCIHandleFree ((dvoid *)conn->svchp, OCI_HTYPE_SVCCTX);
+	}
+	if (conn->errhp)
+		OCIHandleFree ((dvoid *)conn->errhp, OCI_HTYPE_ERROR);
+	/* Decrement connection counter on environment object */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
+	env = lua_touserdata (L, -1);
+	env->conn_counter--;
+	luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
+
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+** Create a new Cursor object and push it on top of the stack.
+*/
+static int create_cursor (lua_State *L, int o, conn_data *conn, OCIStmt *stmt, const char *text) {
+	int i;
+	env_data *env;
+	cur_data *cur = (cur_data *)lua_newuserdata(L, sizeof(cur_data));
+	luasql_setmeta (L, LUASQL_CURSOR_OCI8);
+
+	conn->cur_counter++;
+	/* fill in structure */
+	cur->closed = 0;
+	cur->numcols = 0;
+	cur->colnames = LUA_NOREF;
+	cur->coltypes = LUA_NOREF;
+	cur->curr_tuple = 0;
+	cur->stmthp = stmt;
+	cur->errhp = NULL;
+	cur->cols = NULL;
+	cur->text = strdup (text);
+	cur->modestring = "n";
+	lua_pushvalue (L, o);
+	cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
+
+	/* error handler */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
+	env = lua_touserdata (L, -1);
+	lua_pop (L, 1);
+	ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
+		(dvoid **) &(cur->errhp), (ub4) OCI_HTYPE_ERROR, (size_t) 0,
+		(dvoid **) 0), conn->errhp);
+	/* get number of columns */
+	ASSERT (L, OCIAttrGet ((dvoid *)stmt, (ub4)OCI_HTYPE_STMT,
+		(dvoid *)&cur->numcols, (ub4 *)0, (ub4)OCI_ATTR_PARAM_COUNT,
+		cur->errhp), cur->errhp);
+	cur->cols = (column_data *)malloc (sizeof(column_data) * cur->numcols);
+	/* define output variables */
+	/* Oracle and Lua column indices ranges from 1 to numcols */
+	/* C array indices ranges from 0 to numcols-1 */
+	for (i = 1; i <= cur->numcols; i++) {
+		int ret = alloc_column_buffer (L, cur, i);
+		if (ret)
+			return ret;
+	}
+
+	return 1;
+}
+
+
+/*
+** Execute an SQL statement.
+** Return a Cursor object if the statement is a query, otherwise
+** return the number of tuples affected by the statement.
+*/
+static int conn_execute (lua_State *L) {
+	env_data *env;
+	conn_data *conn = getconnection (L);
+	const char *statement = luaL_checkstring (L, 2);
+	sword status;
+	ub4 prefetch = 0;
+	ub4 iters;
+	ub4 mode;
+	ub2 type;
+	OCIStmt *stmthp;
+
+	/* get environment */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
+	if (!lua_isuserdata (L, -1))
+		luaL_error(L,LUASQL_PREFIX"invalid environment in connection!");
+	env = (env_data *)lua_touserdata (L, -1);
+	/* statement handle */
+	ASSERT (L, OCIHandleAlloc ((dvoid *)env->envhp, (dvoid **)&stmthp,
+		OCI_HTYPE_STMT, (size_t)0, (dvoid **)0), conn->errhp);
+	ASSERT (L, OCIAttrSet ((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT,
+		(dvoid *)&prefetch, (ub4)0, (ub4)OCI_ATTR_PREFETCH_ROWS,
+		conn->errhp), conn->errhp);
+	ASSERT (L, OCIStmtPrepare (stmthp, conn->errhp, (text *)statement,
+		(ub4) strlen(statement), (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT),
+		conn->errhp);
+	/* statement type */
+	ASSERT (L, OCIAttrGet ((dvoid *)stmthp, (ub4) OCI_HTYPE_STMT,
+		(dvoid *)&type, (ub4 *)0, (ub4)OCI_ATTR_STMT_TYPE, conn->errhp),
+		conn->errhp);
+	if (type == OCI_STMT_SELECT)
+		iters = 0;
+	else
+		iters = 1;
+	if (conn->auto_commit)
+		mode = OCI_COMMIT_ON_SUCCESS;
+	else
+		mode = OCI_DEFAULT;
+	/* execute statement */
+	status = OCIStmtExecute (conn->svchp, stmthp, conn->errhp, iters,
+		(ub4)0, (CONST OCISnapshot *)NULL, (OCISnapshot *)NULL, mode);
+	if (status && (status != OCI_NO_DATA)) {
+		OCIHandleFree ((dvoid *)stmthp, OCI_HTYPE_STMT);
+		return checkerr (L, status, conn->errhp);
+	}
+	if (type == OCI_STMT_SELECT) {
+		/* create cursor */
+		return create_cursor (L, 1, conn, stmthp, statement);
+	} else {
+		/* return number of rows */
+		int rows_affected;
+		ASSERT (L, OCIAttrGet ((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT,
+			(dvoid *)&rows_affected, (ub4 *)0,
+			(ub4)OCI_ATTR_ROW_COUNT, conn->errhp), conn->errhp);
+		OCIHandleFree ((dvoid *)stmthp, OCI_HTYPE_STMT);
+		lua_pushnumber (L, rows_affected);
+		return 1;
+	}
+}
+
+
+/*
+** Commit the current transaction.
+*/
+static int conn_commit (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	ASSERT (L, OCITransCommit (conn->svchp, conn->errhp, OCI_DEFAULT),
+		conn->errhp);
+/*
+	if (conn->auto_commit == 0) 
+		ASSERT (L, OCITransStart (conn->svchp, conn->errhp...
+*/
+	return 0;
+}
+
+
+/*
+** Rollback the current transaction.
+*/
+static int conn_rollback (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	ASSERT (L, OCITransRollback (conn->svchp, conn->errhp, OCI_DEFAULT),
+		conn->errhp);
+/*
+	if (conn->auto_commit == 0) 
+		sql_begin(conn); 
+*/
+	return 0;
+}
+
+
+/*
+** Set "auto commit" property of the connection.
+** If 'true', then rollback current transaction.
+** If 'false', then start a new transaction.
+*/
+static void conn_dosetautocommit(lua_State *L, conn_data *conn, int pos){
+	if (lua_toboolean (L, pos)) {
+		conn->auto_commit = 1;
+		/* Undo active transaction. */
+		ASSERT (L, OCITransRollback (conn->svchp, conn->errhp,
+			OCI_DEFAULT), conn->errhp);
+	}
+	else {
+		conn->auto_commit = 0;
+		/* sql_begin(conn);*/
+	}
+}
+
+static int conn_setautocommit (lua_State *L) {
+	conn_data *conn = getconnection (L);
+	conn_dosetautocommit(L, conn, 2);
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+ * Sets the connection parameters
+ */
+static void conn_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					if( lua_isboolean( L, -1 ) )
+						conn_dosetautocommit(L, conn, -1);
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified connection parameters
+ */
+static int conn_get( lua_State *L ) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					lua_pushstring( L, LUASQL_AUTOCOMMIT );
+					lua_pushboolean( L, conn->auto_commit );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+				conn_data *conn = getconnection(L);
+				lua_pushboolean( L, conn->auto_commit );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Connects to a data source.
+*/
+static int env_connect (lua_State *L) {
+	env_data *env = getenvironment (L);
+
+	char *sourcename;
+	char *username;
+	char *password;
+
+	if( lua_istable( L, 2 ) ) {
+		lua_pushstring( L, LUASQL_SOURCENAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			sourcename = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );		
+		lua_pushstring( L, LUASQL_USERNAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			username = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_PASSWORD );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			password = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+	} else {
+		sourcename = luaL_checkstring(L, 2);
+		username = luaL_optstring(L, 3, NULL);
+		password = luaL_optstring(L, 4, NULL);
+	}
+
+	/* Sizes of strings */
+	size_t snlen = strlen(sourcename);
+	size_t userlen = (username) ? strlen(username) : 0;
+	size_t passlen = (password) ? strlen(password) : 0;
+	/* Alloc connection object */
+	conn_data *conn = (conn_data *)lua_newuserdata(L, sizeof(conn_data));
+
+	/* fill in structure */
+	luasql_setmeta (L, LUASQL_CONNECTION_OCI8);
+	conn->env = LUA_NOREF;
+	conn->closed = 1;
+	conn->auto_commit = 1;
+	conn->cur_counter = 0;
+	conn->loggedon = 0;
+	conn->svchp = NULL;
+	conn->errhp = NULL;
+	lua_pushvalue (L, 1);
+	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
+
+	/* error handler */
+	ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
+		(dvoid **) &(conn->errhp), /* !!! */
+		(ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0), env->errhp);
+	/* service handler */
+	/*ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
+		(dvoid **) &(conn->svchp),
+		(ub4) OCI_HTYPE_SVCCTX, (size_t) 0, (dvoid **) 0), conn->errhp);
+*/
+	/* login */
+	ASSERT (L, OCILogon(env->envhp, conn->errhp, &(conn->svchp),
+		(CONST text*)username, userlen,
+		(CONST text*)password, passlen,
+		(CONST text*)sourcename, snlen), conn->errhp);
+	conn->closed = 0;
+	env->conn_counter++;
+	conn->loggedon = 1;
+
+	return 1;
+}
+
+
+/*
+** Close environment object.
+*/
+static int env_close (lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_OCI8);
+	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	if (env->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+	if (env->conn_counter > 0)
+		return luaL_error (L, LUASQL_PREFIX"there are open connections");
+
+	env->closed = 1;
+	/* desalocar: env->errhp e env->envhp */
+	if (env->envhp)
+		OCIHandleFree ((dvoid *)env->envhp, OCI_HTYPE_ENV);
+	if (env->errhp)
+		OCIHandleFree ((dvoid *)env->errhp, OCI_HTYPE_ERROR);
+	lua_pushboolean (L, 1);
+	return 1;
+}
+
+
+/*
+ * Sets the environment parameters
+ */
+static void env_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					if( lua_isnumber( L, -1 ) )
+						env->locktimeout = lua_tointeger( L, -1 );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+/*
+ * Retrieve the specified environment parameters
+ */
+static int env_get(lua_State *L) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+					lua_pushinteger( L, env->locktimeout );
+					lua_settable( L, rsp );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+/*
+			if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+				env_data *env = getenvironment(L);
+				lua_pushinteger( L, env->locktimeout );
+			} else  */
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Creates an Environment and returns it.
+*/
+static int create_environment (lua_State *L) {
+	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
+	luasql_setmeta (L, LUASQL_ENVIRONMENT_OCI8);
+	/* fill in structure */
+	env->closed = 0;
+	env->conn_counter = 0;
+	env->envhp = NULL;
+	env->errhp = NULL;
+/* maybe OCI_SHARED and OCI_THREADED ??? */
+	if (OCIEnvCreate ( &(env->envhp), (ub4)OCI_DEFAULT, (dvoid *)0,
+			(dvoid * (*)(dvoid *, size_t)) 0,
+			(dvoid * (*)(dvoid *, dvoid *, size_t)) 0,
+			(void (*)(dvoid *, dvoid *)) 0,
+			(size_t) 0,
+			(dvoid **) 0))
+		luasql_faildirect (L, LUASQL_PREFIX"couldn't create environment");
+	/* error handler */
+	ASSERT (L, OCIHandleAlloc((dvoid *) env->envhp,
+		(dvoid **) &(env->errhp), /* !!! */
+		(ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0), env->errhp);
+	return 1;
+}
+
+
+/*
+** Create metatables for each class of object.
+*/
+static void create_metatables (lua_State *L) {
+	struct luaL_reg environment_methods[] = {
+		{"__gc", env_close},
+		{"close", env_close},
+		{"connect", env_connect},
+	    {"get", env_get},
+	    {"set", env_set},
+		{NULL, NULL},
+	};
+	struct luaL_reg connection_methods[] = {
+		{"__gc", conn_close},
+		{"close", conn_close},
+		{"execute", conn_execute},
+		{"commit", conn_commit},
+		{"rollback", conn_rollback},
+		{"setautocommit", conn_setautocommit},
+	    {"get", conn_get},
+	    {"set", conn_set},
+		{NULL, NULL},
+	};
+	struct luaL_reg cursor_methods[] = {
+		{"__gc", cur_close},
+		{"close", cur_close},
+		{"getcolnames", cur_getcolnames},
+		{"getcoltypes", cur_getcoltypes},
+		{"fetch", cur_fetch},
+		{"numrows", cur_numrows},
+	    {"get", cur_get},
+	    {"set", cur_set},
+		{NULL, NULL},
+	};
+	luasql_createmeta (L, LUASQL_ENVIRONMENT_OCI8, environment_methods);
+	luasql_createmeta (L, LUASQL_CONNECTION_OCI8, connection_methods);
+	luasql_createmeta (L, LUASQL_CURSOR_OCI8, cursor_methods);
+	luasql_createdefaultoptions( L );
+	lua_pop (L, 3);
+}
+
+
+/*
+** Creates the metatables for the objects and registers the
+** driver open method.
+*/
+LUASQL_API int luaopen_luasql_oci8 (lua_State *L) {
+	struct luaL_reg driver[] = {
+		{"oci8", create_environment},
+		{NULL, NULL},
+	};
+	create_metatables (L);
+	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
+	luasql_set_info (L);
+	return 1;
+}
Index: src/ls_sqlite.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/ls_sqlite.c,v
retrieving revision 1.13
diff -u -r1.13 ls_sqlite.c
--- src/ls_sqlite.c	4 May 2008 02:46:17 -0000	1.13
+++ src/ls_sqlite.c	2 Aug 2008 00:31:39 -0000
@@ -1,579 +1,804 @@
-/*
-** LuaSQL, SQLite driver
-** Author: Tiago Dionizio, Eduardo Quintao
-** See Copyright Notice in license.html
-** $Id: ls_sqlite.c,v 1.13 2008/05/04 02:46:17 tomas Exp $
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-#include "sqlite.h"
-
-#include "lua.h"
-#include "lauxlib.h"
-#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
-#include "compat-5.1.h"
-#endif
-
-
-#include "luasql.h"
-
-#define LUASQL_ENVIRONMENT_SQLITE "SQLite environment"
-#define LUASQL_CONNECTION_SQLITE "SQLite connection"
-#define LUASQL_CURSOR_SQLITE "SQLite cursor"
-
-typedef struct
-{
-    short       closed;
-} env_data;
-
-
-typedef struct
-{
-	short        closed;
-	int          env;                /* reference to environment */
-	short        auto_commit;        /* 0 for manual commit */
-	unsigned int cur_counter;          
-	sqlite      *sql_conn;
-} conn_data;
-
-
-typedef struct
-{
-	short       closed;
-	int         conn;               /* reference to connection */
-	int         numcols;            /* number of columns */
-	int         colnames, coltypes; /* reference to column information tables */
-	sqlite_vm  *sql_vm;
-} cur_data;
-
-LUASQL_API int luaopen_luasql_sqlite(lua_State *L);
-
-
-/*
-** Check for valid environment.
-*/
-static env_data *getenvironment(lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
-	luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	luaL_argcheck(L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
-	return env;
-}
-
-
-/*
-** Check for valid connection.
-*/
-static conn_data *getconnection(lua_State *L) {
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_SQLITE);
-	luaL_argcheck(L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	luaL_argcheck(L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
-	return conn;
-}
-
-
-/*
-** Check for valid cursor.
-*/
-static cur_data *getcursor(lua_State *L) {
-	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_SQLITE);
-	luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	luaL_argcheck(L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
-	return cur;
-}
-
-/*
-** Finalizes the vm
-** Return nil + errmsg or nil in case of sucess
-*/
-static int finalize(lua_State *L, cur_data *cur) {
-    char *errmsg;
-    if (sqlite_finalize(cur->sql_vm, &errmsg) != SQLITE_OK)
-    {
-        cur->sql_vm = NULL;
-        lua_pushnil(L);
-        lua_pushliteral(L, LUASQL_PREFIX);
-        lua_pushstring(L, errmsg);
-        sqlite_freemem(errmsg);
-        lua_concat(L, 2);
-        return 2;
-    }
-	lua_pushnil(L);
-    return 1;
-}
-
-
-/*
-** Get another row of the given cursor.
-*/
-static int cur_fetch (lua_State *L) {
-	cur_data *cur = getcursor(L);
-    sqlite_vm *vm = cur->sql_vm;
-    const char **row = NULL;
-    int res;
-
-    if (vm == NULL)
-        return 0;
-
-    res = sqlite_step(vm, NULL, &row, NULL);
-
-    /* no more results? */
-    if (res == SQLITE_DONE)
-        return finalize(L, cur);
-
-    if (res != SQLITE_ROW)
-        return finalize(L, cur);
-
-	if (lua_istable (L, 2))
-    {
-		int i;
-		const char *opts = luaL_optstring(L, 3, "n");
-
-		if (strchr(opts, 'n') != NULL)
-        {
-			/* Copy values to numerical indices */
-			for (i = 0; i < cur->numcols;)
-            {
-                lua_pushstring(L, row[i]);
-				lua_rawseti(L, 2, ++i);
-			}
-        }
-		if (strchr(opts, 'a') != NULL)
-        {
-			/* Copy values to alphanumerical indices */
-            lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
-
-			for (i = 0; i < cur->numcols; i++)
-            {
-				lua_rawgeti(L, -1, i+1);
-                lua_pushstring(L, row[i]);
-				lua_rawset (L, 2);
-			}
-        }
-		lua_pushvalue(L, 2);
-		return 1; /* return table */
-	}
-	else
-    {
-		int i;
-		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
-		for (i = 0; i < cur->numcols; ++i)
-			lua_pushstring(L, row[i]);
-		return cur->numcols; /* return #numcols values */
-	}
-}
-
-
-/*
-** Close the cursor on top of the stack.
-** Return 1
-*/
-static int cur_close(lua_State *L)
-{
-	conn_data *conn;
-	cur_data *cur = (cur_data *)luaL_checkudata(L, 1, LUASQL_CURSOR_SQLITE);
-	luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	if (cur->closed) {
-		lua_pushboolean(L, 0);
-		return 1;
-	}
-
-	/* Nullify structure fields. */
-	cur->closed = 1;
-	sqlite_finalize(cur->sql_vm, NULL);
-
-	/* Decrement cursor counter on connection object */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
-	conn = lua_touserdata (L, -1);
-	conn->cur_counter--;
-
-	luaL_unref(L, LUA_REGISTRYINDEX, cur->conn);
-	luaL_unref(L, LUA_REGISTRYINDEX, cur->colnames);
-	luaL_unref(L, LUA_REGISTRYINDEX, cur->coltypes);
-
-	lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Return the list of field names.
-*/
-static int cur_getcolnames(lua_State *L)
-{
-    cur_data *cur = getcursor(L);
-    lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
-	return 1;
-}
-
-
-/*
-** Return the list of field types.
-*/
-static int cur_getcoltypes(lua_State *L)
-{
-    cur_data *cur = getcursor(L);
-    lua_rawgeti(L, LUA_REGISTRYINDEX, cur->coltypes);
-	return 1;
-}
-
-
-/*
-** Create a new Cursor object and push it on top of the stack.
-*/
-/* static int create_cursor(lua_State *L, int conn, sqlite_vm *sql_vm,
-    int numcols, const char **row, const char **col_info)*/
-static int create_cursor(lua_State *L, int o, conn_data *conn, 
-		sqlite_vm *sql_vm, int numcols, const char **col_info)
-{
-    int i;
-	cur_data *cur = (cur_data*)lua_newuserdata(L, sizeof(cur_data));
-	luasql_setmeta (L, LUASQL_CURSOR_SQLITE);
-
-	/* increment cursor count for the connection creating this cursor */
-	conn->cur_counter++;
-
-	/* fill in structure */
-	cur->closed = 0;
-	cur->conn = LUA_NOREF;
-	cur->numcols = numcols;
-	cur->colnames = LUA_NOREF;
-	cur->coltypes = LUA_NOREF;
-	cur->sql_vm = sql_vm;
-
-    lua_pushvalue(L, o);
-	cur->conn = luaL_ref(L, LUA_REGISTRYINDEX);
-
-    /* create table with column names */
-    lua_newtable(L);
-    for (i = 0; i < numcols;)
-    {
-        lua_pushstring(L, col_info[i]);
-        lua_rawseti(L, -2, ++i);
-    }
-    cur->colnames = luaL_ref(L, LUA_REGISTRYINDEX);
-
-    /* create table with column types */
-    lua_newtable(L);
-    for (i = 0; i < numcols;)
-    {
-        lua_pushstring(L, col_info[numcols+i]);
-        lua_rawseti(L, -2, ++i);
-    }
-    cur->coltypes = luaL_ref(L, LUA_REGISTRYINDEX);
-
-	return 1;
-}
-
-
-/*
-** Close a Connection object.
-*/
-static int conn_close(lua_State *L)
-{
-	conn_data *conn = (conn_data *)luaL_checkudata(L, 1, LUASQL_CONNECTION_SQLITE);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	if (conn->closed) {
-		lua_pushboolean(L, 0);
-		return 1;
-	}
-
-	if (conn->cur_counter > 0)
-		return luaL_error (L, LUASQL_PREFIX"there are open cursors");
-
-	/* Nullify structure fields. */
-	conn->closed = 1;
-	luaL_unref(L, LUA_REGISTRYINDEX, conn->env);
-    sqlite_close(conn->sql_conn);
-	lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Execute an SQL statement.
-** Return a Cursor object if the statement is a query, otherwise
-** return the number of tuples affected by the statement.
-*/
-static int conn_execute(lua_State *L)
-{
-	conn_data *conn = getconnection(L);
-	const char *statement = luaL_checkstring(L, 2);
-    int res;
-    sqlite_vm *vm;
-    char *errmsg;
-    int numcols;
-    const char **col_info;
-
-    res = sqlite_compile(conn->sql_conn, statement, NULL, &vm, &errmsg);
-    if (res != SQLITE_OK)
-    {
-        lua_pushnil(L);
-        lua_pushliteral(L, LUASQL_PREFIX);
-        lua_pushstring(L, errmsg);
-        sqlite_freemem(errmsg);
-        lua_concat(L, 2);
-        return 2;
-    }
-
-    /* process first result to retrive query information and type */
-    res = sqlite_step(vm, &numcols, NULL, &col_info);
-
-    /* real query? if empty, must have numcols!=0 */
-	if ((res == SQLITE_ROW) || ((res == SQLITE_DONE) && numcols))
-	{
-		sqlite_reset(vm, NULL);
-		return create_cursor(L, 1, conn, vm, numcols, col_info);
-	}
-
-    if (res == SQLITE_DONE) /* and numcols==0, INSERT,UPDATE,DELETE statement */
-    {
-        sqlite_finalize(vm, NULL);
-        /* return number of columns changed */
-        lua_pushnumber(L, sqlite_changes(conn->sql_conn));
-        return 1;
-    }
-
-    /* error */
-    sqlite_finalize(vm, &errmsg);
-    lua_pushnil(L);
-    lua_pushliteral(L, LUASQL_PREFIX);
-    lua_pushstring(L, errmsg);
-    sqlite_freemem(errmsg);
-    lua_concat(L, 2);
-    return 2;
-}
-
-
-/*
-** Commit the current transaction.
-*/
-static int conn_commit(lua_State *L)
-{
-    char *errmsg;
-	conn_data *conn = getconnection(L);
-	int res;
-    const char *sql = "COMMIT";
-
-    if (conn->auto_commit == 0) sql = "COMMIT;BEGIN";
-
-    res = sqlite_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
-    if (res != SQLITE_OK)
-    {
-		lua_pushnil(L);
-        lua_pushliteral(L, LUASQL_PREFIX);
-        lua_pushstring(L, errmsg);
-        sqlite_freemem(errmsg);
-        lua_concat(L, 2);
-        return 2;
-    }
-    lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Rollback the current transaction.
-*/
-static int conn_rollback(lua_State *L)
-{
-    char *errmsg;
-	conn_data *conn = getconnection(L);
-	int res;
-    const char *sql = "ROLLBACK";
-
-    if (conn->auto_commit == 0) sql = "ROLLBACK;BEGIN";
-
-    res = sqlite_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
-    if (res != SQLITE_OK)
-    {
-		lua_pushnil(L);
-        lua_pushliteral(L, LUASQL_PREFIX);
-        lua_pushstring(L, errmsg);
-        sqlite_freemem(errmsg);
-        lua_concat(L, 2);
-        return 2;
-    }
-    lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Set "auto commit" property of the connection.
-** If 'true', then rollback current transaction.
-** If 'false', then start a new transaction.
-*/
-static int conn_setautocommit(lua_State *L)
-{
-	conn_data *conn = getconnection(L);
-	if (lua_toboolean(L, 2))
-    {
-		conn->auto_commit = 1;
-        /* undo active transaction - ignore errors */
-        sqlite_exec(conn->sql_conn, "ROLLBACK", NULL, NULL, NULL);
-	}
-	else
-    {
-        char *errmsg;
-        int res;
-		conn->auto_commit = 0;
-        res = sqlite_exec(conn->sql_conn, "BEGIN", NULL, NULL, &errmsg);
-        if (res != SQLITE_OK)
-        {
-            lua_pushliteral(L, LUASQL_PREFIX);
-            lua_pushstring(L, errmsg);
-            sqlite_freemem(errmsg);
-            lua_concat(L, 2);
-            lua_error(L);
-        }
-	}
-	lua_pushboolean(L, 1);
-	return 1;
-}
-
-
-/*
-** Create a new Connection object and push it on top of the stack.
-*/
-static int create_connection(lua_State *L, int env, sqlite *sql_conn)
-{
-	conn_data *conn = (conn_data*)lua_newuserdata(L, sizeof(conn_data));
-	luasql_setmeta(L, LUASQL_CONNECTION_SQLITE);
-
-	/* fill in structure */
-	conn->closed = 0;
-	conn->env = LUA_NOREF;
-	conn->auto_commit = 1;
-	conn->sql_conn = sql_conn;
-	conn->cur_counter = 0;
-	lua_pushvalue (L, env);
-	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
-	return 1;
-}
-
-
-/*
-** Connects to a data source.
-*/
-static int env_connect(lua_State *L)
-{
-    const char *sourcename;
-	sqlite *conn;
-    char *errmsg;
-	getenvironment(L);  /* validate environment */
-    sourcename = luaL_checkstring(L, 2);
-    conn = sqlite_open(sourcename, 0, &errmsg);
-    if (conn == NULL)
-    {
-        lua_pushnil(L);
-        lua_pushliteral(L, LUASQL_PREFIX);
-        lua_pushstring(L, errmsg);
-        sqlite_freemem(errmsg);
-        lua_concat(L, 2);
-        return 2;
-    }
-    return create_connection(L, 1, conn);
-}
-
-
-/*
-** Close environment object.
-*/
-static int env_close (lua_State *L)
-{
-	env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
-	luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	if (env->closed) {
-		lua_pushboolean(L, 0);
-		return 1;
-	}
-
-	env->closed = 1;
-	lua_pushboolean(L, 1);
-	return 1;
-}
-
-static int conn_escape(lua_State *L)
-{
-    const char *from = luaL_checklstring (L, 2, 0);
-    char *escaped = sqlite_mprintf("%q", from);
-    if (escaped == NULL) 
-    {
-        lua_pushnil(L);
-    } 
-    else
-    {
-        lua_pushstring(L, escaped);        
-        sqlite_freemem(escaped);
-    }
-    return 1;
-}
-
-/*
-** Create metatables for each class of object.
-*/
-static void create_metatables (lua_State *L)
-{
-    struct luaL_reg environment_methods[] = {
-        {"__gc", env_close},
-        {"close", env_close},
-        {"connect", env_connect},
-		{NULL, NULL},
-	};
-    struct luaL_reg connection_methods[] = {
-        {"__gc", conn_close},
-        {"close", conn_close},
-		{"escape", conn_escape},
-        {"execute", conn_execute},
-        {"commit", conn_commit},
-        {"rollback", conn_rollback},
-        {"setautocommit", conn_setautocommit},
-		{NULL, NULL},
-    };
-    struct luaL_reg cursor_methods[] = {
-        {"__gc", cur_close},
-        {"close", cur_close},
-        {"getcolnames", cur_getcolnames},
-        {"getcoltypes", cur_getcoltypes},
-        {"fetch", cur_fetch},
-		{NULL, NULL},
-    };
-	luasql_createmeta(L, LUASQL_ENVIRONMENT_SQLITE, environment_methods);
-	luasql_createmeta(L, LUASQL_CONNECTION_SQLITE, connection_methods);
-	luasql_createmeta(L, LUASQL_CURSOR_SQLITE, cursor_methods);
-	lua_pop (L, 3);
-}
-
-/*
-** Creates an Environment and returns it.
-*/
-static int create_environment (lua_State *L)
-{
-	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
-	luasql_setmeta(L, LUASQL_ENVIRONMENT_SQLITE);
-
-	/* fill in structure */
-	env->closed = 0;
-	return 1;
-}
-
-
-/*
-** Creates the metatables for the objects and registers the
-** driver open method.
-*/
-LUASQL_API int luaopen_luasql_sqlite(lua_State *L)
-{
-	struct luaL_reg driver[] = {
-		{"sqlite", create_environment},
-		{NULL, NULL},
-	};
-	create_metatables (L);
-	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
-	luasql_set_info (L);
-	return 1;
-}
+/*
+** LuaSQL, SQLite driver
+** Author: Tiago Dionizio, Eduardo Quintao
+** See Copyright Notice in license.html
+** $Id: ls_sqlite.c,v 1.13 2008/05/04 02:46:17 tomas Exp $
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "sqlite.h"
+
+#include "lua.h"
+#include "lauxlib.h"
+#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
+#include "compat-5.1.h"
+#endif
+
+
+#include "luasql.h"
+
+#define LUASQL_ENVIRONMENT_SQLITE "SQLite environment"
+#define LUASQL_CONNECTION_SQLITE "SQLite connection"
+#define LUASQL_CURSOR_SQLITE "SQLite cursor"
+#define LUASQL_LOCKTIMEOUT "locktimeout"
+
+typedef struct
+{
+    short       closed;
+    int			locktimeout;
+} env_data;
+
+
+typedef struct
+{
+	short        closed;
+	int          env;                /* reference to environment */
+	short        auto_commit;        /* 0 for manual commit */
+	unsigned int cur_counter;          
+	sqlite      *sql_conn;
+} conn_data;
+
+
+typedef struct
+{
+	short       closed;
+	int         conn;               /* reference to connection */
+	int         numcols;            /* number of columns */
+	int         colnames, coltypes; /* reference to column information tables */
+	sqlite_vm  *sql_vm;
+	char	   *modestring;
+} cur_data;
+
+LUASQL_API int luaopen_luasql_sqlite(lua_State *L);
+
+
+/*
+** Check for valid environment.
+*/
+static env_data *getenvironment(lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
+	luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	luaL_argcheck(L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
+	return env;
+}
+
+
+/*
+** Check for valid connection.
+*/
+static conn_data *getconnection(lua_State *L) {
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_SQLITE);
+	luaL_argcheck(L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	luaL_argcheck(L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
+	return conn;
+}
+
+
+/*
+** Check for valid cursor.
+*/
+static cur_data *getcursor(lua_State *L) {
+	cur_data *cur = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_SQLITE);
+	luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	luaL_argcheck(L, !cur->closed, 1, LUASQL_PREFIX"cursor is closed");
+	return cur;
+}
+
+/*
+** Finalizes the vm
+** Return nil + errmsg or nil in case of sucess
+*/
+static int finalize(lua_State *L, cur_data *cur) {
+    char *errmsg;
+    if (sqlite_finalize(cur->sql_vm, &errmsg) != SQLITE_OK)
+    {
+        cur->sql_vm = NULL;
+        lua_pushnil(L);
+        lua_pushliteral(L, LUASQL_PREFIX);
+        lua_pushstring(L, errmsg);
+        sqlite_freemem(errmsg);
+        lua_concat(L, 2);
+        return 2;
+    }
+	lua_pushnil(L);
+    return 1;
+}
+
+
+/*
+** Get another row of the given cursor.
+*/
+static int cur_fetch (lua_State *L) {
+	cur_data *cur = getcursor(L);
+    sqlite_vm *vm = cur->sql_vm;
+    const char **row = NULL;
+    int res;
+
+    if (vm == NULL)
+        return 0;
+
+    res = sqlite_step(vm, NULL, &row, NULL);
+
+    /* no more results? */
+    if (res == SQLITE_DONE)
+        return finalize(L, cur);
+
+    if (res != SQLITE_ROW)
+        return finalize(L, cur);
+
+	if (lua_istable (L, 2))
+    {
+		int i;
+        const char *opts = luasql_getfetchmodestring( L, cur->modestring );
+
+		if (strchr(opts, 'n') != NULL)
+        {
+			/* Copy values to numerical indices */
+			for (i = 0; i < cur->numcols;)
+            {
+                lua_pushstring(L, row[i]);
+				lua_rawseti(L, 2, ++i);
+			}
+        }
+		if (strchr(opts, 'a') != NULL)
+        {
+			/* Copy values to alphanumerical indices */
+            lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
+
+			for (i = 0; i < cur->numcols; i++)
+            {
+				lua_rawgeti(L, -1, i+1);
+                lua_pushstring(L, row[i]);
+				lua_rawset (L, 2);
+			}
+        }
+		lua_pushvalue(L, 2);
+		return 1; /* return table */
+	}
+	else
+    {
+		int i;
+		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
+		for (i = 0; i < cur->numcols; ++i)
+			lua_pushstring(L, row[i]);
+		return cur->numcols; /* return #numcols values */
+	}
+}
+
+
+/*
+** Close the cursor on top of the stack.
+** Return 1
+*/
+static int cur_close(lua_State *L)
+{
+	conn_data *conn;
+	cur_data *cur = (cur_data *)luaL_checkudata(L, 1, LUASQL_CURSOR_SQLITE);
+	luaL_argcheck(L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	if (cur->closed) {
+		lua_pushboolean(L, 0);
+		return 1;
+	}
+
+	/* Nullify structure fields. */
+	cur->closed = 1;
+	sqlite_finalize(cur->sql_vm, NULL);
+
+	/* Decrement cursor counter on connection object */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
+	conn = lua_touserdata (L, -1);
+	conn->cur_counter--;
+
+	luaL_unref(L, LUA_REGISTRYINDEX, cur->conn);
+	luaL_unref(L, LUA_REGISTRYINDEX, cur->colnames);
+	luaL_unref(L, LUA_REGISTRYINDEX, cur->coltypes);
+
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+** Return the list of field names.
+*/
+static int cur_getcolnames(lua_State *L)
+{
+    cur_data *cur = getcursor(L);
+    lua_rawgeti(L, LUA_REGISTRYINDEX, cur->colnames);
+	return 1;
+}
+
+
+/*
+** Return the list of field types.
+*/
+static int cur_getcoltypes(lua_State *L)
+{
+    cur_data *cur = getcursor(L);
+    lua_rawgeti(L, LUA_REGISTRYINDEX, cur->coltypes);
+	return 1;
+}
+
+
+/*
+ * Sets the cursor parameters
+ */
+static void cur_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					if( lua_isstring( L, -1 ) )
+						cur->modestring = lua_tostring( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified cursor parameters
+ */
+static int cur_get( lua_State *L ) {
+	if( lua_istable( L, 2 ) ) {
+		lua_newtable(L);
+		int rsp = lua_gettop(L);
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					lua_pushstring( L, LUASQL_MODESTRING );
+					lua_pushstring( L, cur->modestring );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+				cur_data *cur = getcursor(L);
+				lua_pushstring( L, cur->modestring );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Cursor object and push it on top of the stack.
+*/
+/* static int create_cursor(lua_State *L, int conn, sqlite_vm *sql_vm,
+    int numcols, const char **row, const char **col_info)*/
+static int create_cursor(lua_State *L, int o, conn_data *conn, 
+		sqlite_vm *sql_vm, int numcols, const char **col_info)
+{
+    int i;
+	cur_data *cur = (cur_data*)lua_newuserdata(L, sizeof(cur_data));
+	luasql_setmeta (L, LUASQL_CURSOR_SQLITE);
+
+	/* increment cursor count for the connection creating this cursor */
+	conn->cur_counter++;
+
+	/* fill in structure */
+	cur->closed = 0;
+	cur->conn = LUA_NOREF;
+	cur->numcols = numcols;
+	cur->colnames = LUA_NOREF;
+	cur->coltypes = LUA_NOREF;
+	cur->sql_vm = sql_vm;
+	cur->modestring = "n";
+
+    lua_pushvalue(L, o);
+	cur->conn = luaL_ref(L, LUA_REGISTRYINDEX);
+
+    /* create table with column names */
+    lua_newtable(L);
+    for (i = 0; i < numcols;)
+    {
+        lua_pushstring(L, col_info[i]);
+        lua_rawseti(L, -2, ++i);
+    }
+    cur->colnames = luaL_ref(L, LUA_REGISTRYINDEX);
+
+    /* create table with column types */
+    lua_newtable(L);
+    for (i = 0; i < numcols;)
+    {
+        lua_pushstring(L, col_info[numcols+i]);
+        lua_rawseti(L, -2, ++i);
+    }
+    cur->coltypes = luaL_ref(L, LUA_REGISTRYINDEX);
+
+	return 1;
+}
+
+
+/*
+** Close a Connection object.
+*/
+static int conn_close(lua_State *L)
+{
+	conn_data *conn = (conn_data *)luaL_checkudata(L, 1, LUASQL_CONNECTION_SQLITE);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	if (conn->closed) {
+		lua_pushboolean(L, 0);
+		return 1;
+	}
+
+	if (conn->cur_counter > 0)
+		return luaL_error (L, LUASQL_PREFIX"there are open cursors");
+
+	/* Nullify structure fields. */
+	conn->closed = 1;
+	luaL_unref(L, LUA_REGISTRYINDEX, conn->env);
+    sqlite_close(conn->sql_conn);
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+** Execute an SQL statement.
+** Return a Cursor object if the statement is a query, otherwise
+** return the number of tuples affected by the statement.
+*/
+static int conn_execute(lua_State *L)
+{
+	conn_data *conn = getconnection(L);
+	const char *statement = luaL_checkstring(L, 2);
+    int res;
+    sqlite_vm *vm;
+    char *errmsg;
+    int numcols;
+    const char **col_info;
+
+    res = sqlite_compile(conn->sql_conn, statement, NULL, &vm, &errmsg);
+    if (res != SQLITE_OK)
+    {
+        lua_pushnil(L);
+        lua_pushliteral(L, LUASQL_PREFIX);
+        lua_pushstring(L, errmsg);
+        sqlite_freemem(errmsg);
+        lua_concat(L, 2);
+        return 2;
+    }
+
+    /* process first result to retrive query information and type */
+    res = sqlite_step(vm, &numcols, NULL, &col_info);
+
+    /* real query? if empty, must have numcols!=0 */
+	if ((res == SQLITE_ROW) || ((res == SQLITE_DONE) && numcols))
+	{
+		sqlite_reset(vm, NULL);
+		return create_cursor(L, 1, conn, vm, numcols, col_info);
+	}
+
+    if (res == SQLITE_DONE) /* and numcols==0, INSERT,UPDATE,DELETE statement */
+    {
+        sqlite_finalize(vm, NULL);
+        /* return number of columns changed */
+        lua_pushnumber(L, sqlite_changes(conn->sql_conn));
+        return 1;
+    }
+
+    /* error */
+    sqlite_finalize(vm, &errmsg);
+    lua_pushnil(L);
+    lua_pushliteral(L, LUASQL_PREFIX);
+    lua_pushstring(L, errmsg);
+    sqlite_freemem(errmsg);
+    lua_concat(L, 2);
+    return 2;
+}
+
+
+/*
+** Commit the current transaction.
+*/
+static int conn_commit(lua_State *L)
+{
+    char *errmsg;
+	conn_data *conn = getconnection(L);
+	int res;
+    const char *sql = "COMMIT";
+
+    if (conn->auto_commit == 0) sql = "COMMIT;BEGIN";
+
+    res = sqlite_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
+    if (res != SQLITE_OK)
+    {
+		lua_pushnil(L);
+        lua_pushliteral(L, LUASQL_PREFIX);
+        lua_pushstring(L, errmsg);
+        sqlite_freemem(errmsg);
+        lua_concat(L, 2);
+        return 2;
+    }
+    lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+** Rollback the current transaction.
+*/
+static int conn_rollback(lua_State *L)
+{
+    char *errmsg;
+	conn_data *conn = getconnection(L);
+	int res;
+    const char *sql = "ROLLBACK";
+
+    if (conn->auto_commit == 0) sql = "ROLLBACK;BEGIN";
+
+    res = sqlite_exec(conn->sql_conn, sql, NULL, NULL, &errmsg);
+    if (res != SQLITE_OK)
+    {
+		lua_pushnil(L);
+        lua_pushliteral(L, LUASQL_PREFIX);
+        lua_pushstring(L, errmsg);
+        sqlite_freemem(errmsg);
+        lua_concat(L, 2);
+        return 2;
+    }
+    lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+** Set "auto commit" property of the connection.
+** If 'true', then rollback current transaction.
+** If 'false', then start a new transaction.
+*/
+static void conn_dosetautocommit(lua_State *L, conn_data *conn, int pos) {
+	if (lua_toboolean(L, pos))
+	{
+		conn->auto_commit = 1;
+        /* undo active transaction - ignore errors */
+	    sqlite3_exec(conn->sql_conn, "ROLLBACK", NULL, NULL, NULL);
+	}
+	else
+	{
+		char *errmsg;
+	    int res;
+	    conn->auto_commit = 0;
+	    res = sqlite3_exec(conn->sql_conn, "BEGIN", NULL, NULL, &errmsg);
+
+	    if (res != SQLITE_OK) {
+	    	lua_pushliteral(L, LUASQL_PREFIX);
+	    	lua_pushstring(L, errmsg);
+	    	sqlite3_free(errmsg);
+	    	lua_concat(L, 2);
+	    	lua_error(L);
+	    }
+	}
+}
+
+
+static int conn_setautocommit(lua_State *L)
+{
+	conn_data *conn = getconnection(L);
+	conn_dosetautocommit(L, conn, 2);
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+
+/*
+ * Sets the connection parameters
+ */
+static void conn_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					if( lua_isboolean( L, -1 ) )
+						conn_dosetautocommit(L, conn, -1);
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified connection parameters
+ */
+static int conn_get( lua_State *L ) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					lua_pushstring( L, LUASQL_AUTOCOMMIT );
+					lua_pushboolean( L, conn->auto_commit );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+				conn_data *conn = getconnection(L);
+				lua_pushboolean( L, conn->auto_commit );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Connection object and push it on top of the stack.
+*/
+static int create_connection(lua_State *L, int env, sqlite *sql_conn)
+{
+	conn_data *conn = (conn_data*)lua_newuserdata(L, sizeof(conn_data));
+	luasql_setmeta(L, LUASQL_CONNECTION_SQLITE);
+
+	/* fill in structure */
+	conn->closed = 0;
+	conn->env = LUA_NOREF;
+	conn->auto_commit = 1;
+	conn->sql_conn = sql_conn;
+	conn->cur_counter = 0;
+	lua_pushvalue (L, env);
+	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
+	return 1;
+}
+
+
+/*
+** Connects to a data source.
+*/
+static int env_connect(lua_State *L)
+{
+    char *sourcename;
+	sqlite *conn;
+    char *errmsg;
+	getenvironment(L);  /* validate environment */
+
+	if( lua_istable( L, 2 ) ) {
+		lua_pushstring( L, LUASQL_SOURCENAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			sourcename = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );		
+	} else {
+		sourcename = luaL_checkstring(L, 2);
+	}
+
+    conn = sqlite_open(sourcename, 0, &errmsg);
+
+    if (conn == NULL)
+    {
+        lua_pushnil(L);
+        lua_pushliteral(L, LUASQL_PREFIX);
+        lua_pushstring(L, errmsg);
+        sqlite_freemem(errmsg);
+        lua_concat(L, 2);
+        return 2;
+    }
+
+    return create_connection(L, 1, conn);
+}
+
+
+/*
+** Close environment object.
+*/
+static int env_close (lua_State *L)
+{
+	env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_SQLITE);
+	luaL_argcheck(L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	if (env->closed) {
+		lua_pushboolean(L, 0);
+		return 1;
+	}
+
+	env->closed = 1;
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+static int conn_escape(lua_State *L)
+{
+    const char *from = luaL_checklstring (L, 2, 0);
+    char *escaped = sqlite_mprintf("%q", from);
+    if (escaped == NULL) 
+    {
+        lua_pushnil(L);
+    } 
+    else
+    {
+        lua_pushstring(L, escaped);        
+        sqlite_freemem(escaped);
+    }
+    return 1;
+}
+
+/*
+ * Sets the environment parameters
+ */
+static void env_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					if( lua_isnumber( L, -1 ) )
+						env->locktimeout = lua_tointeger( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+/*
+ * Retrieve the specified environment parameters
+ */
+static int env_get(lua_State *L) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+					lua_pushinteger( L, env->locktimeout );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+				env_data *env = getenvironment(L);
+				lua_pushinteger( L, env->locktimeout );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create metatables for each class of object.
+*/
+static void create_metatables (lua_State *L)
+{
+    struct luaL_reg environment_methods[] = {
+        {"__gc", env_close},
+        {"close", env_close},
+        {"connect", env_connect},
+        {"get", env_get},
+        {"set", env_set},
+		{NULL, NULL},
+	};
+    struct luaL_reg connection_methods[] = {
+        {"__gc", conn_close},
+        {"close", conn_close},
+		{"escape", conn_escape},
+        {"execute", conn_execute},
+        {"commit", conn_commit},
+        {"rollback", conn_rollback},
+        {"setautocommit", conn_setautocommit},
+        {"get", conn_get},
+        {"set", conn_set},
+		{NULL, NULL},
+    };
+    struct luaL_reg cursor_methods[] = {
+        {"__gc", cur_close},
+        {"close", cur_close},
+        {"getcolnames", cur_getcolnames},
+        {"getcoltypes", cur_getcoltypes},
+        {"fetch", cur_fetch},
+        {"get", cur_get},
+        {"set", cur_set},
+		{NULL, NULL},
+    };
+	luasql_createmeta(L, LUASQL_ENVIRONMENT_SQLITE, environment_methods);
+	luasql_createmeta(L, LUASQL_CONNECTION_SQLITE, connection_methods);
+	luasql_createmeta(L, LUASQL_CURSOR_SQLITE, cursor_methods);
+	lua_pop (L, 3);
+}
+
+/*
+** Creates an Environment and returns it.
+*/
+static int create_environment (lua_State *L)
+{
+	env_data *env = (env_data *)lua_newuserdata(L, sizeof(env_data));
+	luasql_setmeta(L, LUASQL_ENVIRONMENT_SQLITE);
+
+	/* fill in structure */
+	env->closed = 0;
+	return 1;
+}
+
+
+/*
+** Creates the metatables for the objects and registers the
+** driver open method.
+*/
+LUASQL_API int luaopen_luasql_sqlite(lua_State *L)
+{
+	struct luaL_reg driver[] = {
+		{"sqlite", create_environment},
+		{NULL, NULL},
+	};
+	create_metatables (L);
+	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
+	luasql_set_info (L);
+	return 1;
+}
Index: src/ls_odbc.c
===================================================================
RCS file: /cvsroot/luasql/luasql/src/ls_odbc.c,v
retrieving revision 1.38
diff -u -r1.38 ls_odbc.c
--- src/ls_odbc.c	4 May 2008 02:46:17 -0000	1.38
+++ src/ls_odbc.c	2 Aug 2008 00:31:39 -0000
@@ -1,712 +1,950 @@
-/*
-** LuaSQL, ODBC driver
-** Authors: Pedro Rabinovitch, Roberto Ierusalimschy, Diego Nehab,
-** Tomas Guisasola
-** See Copyright Notice in license.html
-** $Id: ls_odbc.c,v 1.38 2008/05/04 02:46:17 tomas Exp $
-*/
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-
-#if defined(_WIN32)
-#include <windows.h>
-#include <sqlext.h>
-#elif defined(INFORMIX)
-#include "infxcli.h"
-#elif defined(UNIXODBC)
-#include "sql.h"
-#include "sqltypes.h"
-#include "sqlext.h"
-#endif
-
-#include "lua.h"
-#include "lauxlib.h"
-#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
-#include "compat-5.1.h"
-#endif
-
-
-#include "luasql.h"
-
-#define LUASQL_ENVIRONMENT_ODBC "ODBC environment"
-#define LUASQL_CONNECTION_ODBC "ODBC connection"
-#define LUASQL_CURSOR_ODBC "ODBC cursor"
-
-
-typedef struct {
-	short      closed;
-	int        conn_counter;
-	SQLHENV    henv;               /* environment handle */
-} env_data;
-
-
-typedef struct {
-	short      closed;
-	int        cur_counter;
-	int        env;                /* reference to environment */
-	SQLHDBC    hdbc;               /* database connection handle */
-} conn_data;
-
-
-typedef struct {
-	short      closed;
-	int        conn;               /* reference to connection */
-	int        numcols;            /* number of columns */
-	int        coltypes, colnames; /* reference to column information tables */
-	SQLHSTMT   hstmt;              /* statement handle */
-} cur_data;
-
-
-/* we are lazy */
-#define hENV SQL_HANDLE_ENV
-#define hSTMT SQL_HANDLE_STMT
-#define hDBC SQL_HANDLE_DBC
-#define error(a) ((a) != SQL_SUCCESS && (a) != SQL_SUCCESS_WITH_INFO) 
-
-
-LUASQL_API int luaopen_luasql_odbc (lua_State *L);
-
-/*
-** Check for valid environment.
-*/
-static env_data *getenvironment (lua_State *L) {
-	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_ODBC);
-	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	luaL_argcheck (L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
-	return env;
-}
-
-
-/*
-** Check for valid connection.
-*/
-static conn_data *getconnection (lua_State *L) {
-	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_ODBC);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	luaL_argcheck (L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
-	return conn;
-}
-
-
-/*
-** Check for valid cursor.
-*/
-static cur_data *getcursor (lua_State *L) {
-	cur_data *cursor = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_ODBC);
-	luaL_argcheck (L, cursor != NULL, 1, LUASQL_PREFIX"cursor expected");
-	luaL_argcheck (L, !cursor->closed, 1, LUASQL_PREFIX"cursor is closed");
-	return cursor;
-}
-
-
-/*
-** Pushes true and returns 1
-*/
-static int pass(lua_State *L) {
-    lua_pushboolean (L, 1);
-    return 1;
-}
-
-
-/*
-** Fails with error message from ODBC
-** Inputs: 
-**   type: type of handle used in operation
-**   handle: handle used in operation
-*/
-static int fail(lua_State *L,  const SQLSMALLINT type, const SQLHANDLE handle) {
-    SQLCHAR State[6];
-    SQLINTEGER NativeError;
-    SQLSMALLINT MsgSize, i;
-    SQLRETURN ret;
-    char Msg[SQL_MAX_MESSAGE_LENGTH];
-    luaL_Buffer b;
-    lua_pushnil(L);
-
-    luaL_buffinit(L, &b);
-    i = 1;
-    while (1) {
-        ret = SQLGetDiagRec(type, handle, i, State, &NativeError, Msg, 
-                sizeof(Msg), &MsgSize);
-        if (ret == SQL_NO_DATA) break;
-        luaL_addlstring(&b, Msg, MsgSize);
-        luaL_putchar(&b, '\n');
-        i++;
-    } 
-    luaL_pushresult(&b);
-    return 2;
-}
-
-/*
-** Returns the name of an equivalent lua type for a SQL type.
-*/
-static const char *sqltypetolua (const SQLSMALLINT type) {
-    switch (type) {
-        case SQL_UNKNOWN_TYPE: case SQL_CHAR: case SQL_VARCHAR: 
-        case SQL_TYPE_DATE: case SQL_TYPE_TIME: case SQL_TYPE_TIMESTAMP: 
-        case SQL_DATE: case SQL_INTERVAL: case SQL_TIMESTAMP: 
-        case SQL_LONGVARCHAR:
-            return "string";
-        case SQL_BIGINT: case SQL_TINYINT: case SQL_NUMERIC: 
-        case SQL_DECIMAL: case SQL_INTEGER: case SQL_SMALLINT: 
-        case SQL_FLOAT: case SQL_REAL: case SQL_DOUBLE:
-            return "number";
-        case SQL_BINARY: case SQL_VARBINARY: case SQL_LONGVARBINARY:
-            return "binary";	/* !!!!!! nao seria string? */
-        case SQL_BIT:
-            return "boolean";
-        default:
-            assert(0);
-            return NULL;
-    }
-}
-
-
-/*
-** Retrieves data from the i_th column in the current row
-** Input
-**   types: index in stack of column types table
-**   hstmt: statement handle
-**   i: column number
-** Returns:
-**   0 if successfull, non-zero otherwise;
-*/
-static int push_column(lua_State *L, int coltypes, const SQLHSTMT hstmt, 
-        SQLUSMALLINT i) {
-    const char *tname;
-    char type;
-    /* get column type from types table */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, coltypes);
-	lua_rawgeti (L, -1, i);	/* typename of the column */
-    tname = lua_tostring(L, -1);
-    if (!tname)
-		return luasql_faildirect(L, LUASQL_PREFIX"Invalid type in table.");
-    type = tname[1];
-    lua_pop(L, 2);	/* pops type name and coltypes table */
-
-    /* deal with data according to type */
-    switch (type) {
-        /* nUmber */
-        case 'u': { 
-			double num;
-			SQLINTEGER got;
-			SQLRETURN rc = SQLGetData(hstmt, i, SQL_C_DOUBLE, &num, 0, &got);
-			if (error(rc))
-				return fail(L, hSTMT, hstmt);
-			if (got == SQL_NULL_DATA)
-				lua_pushnil(L);
-			else
-				lua_pushnumber(L, num);
-			return 0;
-		}
-                  /* bOol */
-        case 'o': { 
-			char b;
-			SQLINTEGER got;
-			SQLRETURN rc = SQLGetData(hstmt, i, SQL_C_BIT, &b, 0, &got);
-			if (error(rc))
-				return fail(L, hSTMT, hstmt);
-			if (got == SQL_NULL_DATA)
-				lua_pushnil(L);
-			else
-				lua_pushboolean(L, b);
-			return 0;
-		}
-        /* sTring */
-        case 't': 
-        /* bInary */
-        case 'i': { 
-			SQLSMALLINT stype = (type == 't') ? SQL_C_CHAR : SQL_C_BINARY;
-			SQLINTEGER got;
-			char *buffer;
-			luaL_Buffer b;
-			SQLRETURN rc;
-			luaL_buffinit(L, &b);
-			buffer = luaL_prepbuffer(&b);
-			rc = SQLGetData(hstmt, i, stype, buffer, LUAL_BUFFERSIZE, &got);
-			if (got == SQL_NULL_DATA) {
-				lua_pushnil(L);
-				return 0;
-			}
-			/* concat intermediary chunks */
-			while (rc == SQL_SUCCESS_WITH_INFO) {
-				if (got >= LUAL_BUFFERSIZE || got == SQL_NO_TOTAL) {
-					got = LUAL_BUFFERSIZE;
-					/* get rid of null termination in string block */
-					if (stype == SQL_C_CHAR) got--;
-				}
-				luaL_addsize(&b, got);
-				buffer = luaL_prepbuffer(&b);
-				rc = SQLGetData(hstmt, i, stype, buffer, 
-					LUAL_BUFFERSIZE, &got);
-			}
-			/* concat last chunk */
-			if (rc == SQL_SUCCESS) {
-				if (got >= LUAL_BUFFERSIZE || got == SQL_NO_TOTAL) {
-					got = LUAL_BUFFERSIZE;
-					/* get rid of null termination in string block */
-					if (stype == SQL_C_CHAR) got--;
-				}
-				luaL_addsize(&b, got);
-			}
-			if (rc == SQL_ERROR) return fail(L, hSTMT, hstmt);
-			/* return everything we got */
-			luaL_pushresult(&b);
-			return 0;
-		}
-    }
-    return 0;
-}
-
-/*
-** Get another row of the given cursor.
-*/
-static int cur_fetch (lua_State *L) {
-    cur_data *cur = (cur_data *) getcursor (L);
-    SQLHSTMT hstmt = cur->hstmt;
-    int ret; 
-    SQLRETURN rc = SQLFetch(cur->hstmt); 
-    if (rc == SQL_NO_DATA) {
-        lua_pushnil(L);
-        return 1;
-    } else if (error(rc)) return fail(L, hSTMT, hstmt);
-
-	if (lua_istable (L, 2)) {
-		SQLUSMALLINT i;
-		const char *opts = luaL_optstring (L, 3, "n");
-		int num = strchr (opts, 'n') != NULL;
-		int alpha = strchr (opts, 'a') != NULL;
-		for (i = 1; i <= cur->numcols; i++) {
-			ret = push_column (L, cur->coltypes, hstmt, i);
-			if (ret)
-				return ret;
-			if (alpha) {
-				lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);
-				lua_rawgeti (L, -1, i); /* gets column name */
-				lua_pushvalue (L, -3); /* duplicates column value */
-				lua_rawset (L, 2); /* table[name] = value */
-				lua_pop (L, 1);	/* pops colnames table */
-			}
-			if (num)
-				lua_rawseti (L, 2, i);
-			else
-				lua_pop (L, 1); /* pops value */
-		}
-		lua_pushvalue (L, 2);
-		return 1;	/* return table */
-	}
-	else {
-		SQLUSMALLINT i;
-		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
-		for (i = 1; i <= cur->numcols; i++) {
-			ret = push_column (L, cur->coltypes, hstmt, i);
-			if (ret)
-				return ret;
-		}
-		return cur->numcols;
-	}
-}
-
-/*
-** Closes a cursor.
-*/
-static int cur_close (lua_State *L) {
-	conn_data *conn;
-	cur_data *cur = (cur_data *) luaL_checkudata (L, 1, LUASQL_CURSOR_ODBC);
-	SQLRETURN ret;
-	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
-	if (cur->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-
-	/* Nullify structure fields. */
-	cur->closed = 1;
-	ret = SQLCloseCursor(cur->hstmt);
-    if (error(ret))
-		return fail(L, hSTMT, cur->hstmt);
-	ret = SQLFreeHandle(hSTMT, cur->hstmt);
-	if (error(ret))
-		return fail(L, hSTMT, cur->hstmt);
-	/* Decrement cursor counter on connection object */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
-	conn = lua_touserdata (L, -1);
-	conn->cur_counter--;
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
-	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
-    return pass(L);
-}
-
-
-/*
-** Returns the table with column names.
-*/
-static int cur_colnames (lua_State *L) {
-	cur_data *cur = (cur_data *) getcursor (L);
-	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);
-	return 1;
-}
-
-
-/*
-** Returns the table with column types.
-*/
-static int cur_coltypes (lua_State *L) {
-	cur_data *cur = (cur_data *) getcursor (L);
-	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->coltypes);
-	return 1;
-}
-
-
-/*
-** Creates two tables with the names and the types of the columns.
-*/
-static void create_colinfo (lua_State *L, cur_data *cur) {
-	SQLCHAR buffer[256];
-	SQLSMALLINT namelen, datatype, i;
-	SQLRETURN ret;
-	int types, names;
-
-	lua_newtable(L);
-	types = lua_gettop (L);
-	lua_newtable(L);
-	names = lua_gettop (L);
-	for (i = 1; i <= cur->numcols; i++) {
-		ret = SQLDescribeCol(cur->hstmt, i, buffer, sizeof(buffer), 
-                &namelen, &datatype, NULL, NULL, NULL);
-		/*if (ret == SQL_ERROR) return fail(L, hSTMT, cur->hstmt);*/
-		lua_pushstring (L, buffer);
-		lua_rawseti (L, names, i);
-		lua_pushstring(L, sqltypetolua(datatype));
-		lua_rawseti (L, types, i);
-	}
-	cur->colnames = luaL_ref (L, LUA_REGISTRYINDEX);
-	cur->coltypes = luaL_ref (L, LUA_REGISTRYINDEX);
-}
-
-
-/*
-** Creates a cursor table and leave it on the top of the stack.
-*/
-static int create_cursor (lua_State *L, int o, conn_data *conn, 
-        const SQLHSTMT hstmt, const SQLSMALLINT numcols) {
-    cur_data *cur = (cur_data *) lua_newuserdata(L, sizeof(cur_data));
-	luasql_setmeta (L, LUASQL_CURSOR_ODBC);
-
-	conn->cur_counter++;
-    /* fill in structure */
-	cur->closed = 0;
-	cur->conn = LUA_NOREF;
-    cur->numcols = numcols;
-	cur->colnames = LUA_NOREF;
-	cur->coltypes = LUA_NOREF;
-    cur->hstmt = hstmt;
-	lua_pushvalue (L, o);
-    cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
-
-	/* make and store column information table */
-	create_colinfo (L, cur);
-
-    return 1;
-}
-
-
-/*
-** Closes a connection.
-*/
-static int conn_close (lua_State *L) {
-	SQLRETURN ret;
-	env_data *env;
-    conn_data *conn = (conn_data *)luaL_checkudata(L,1,LUASQL_CONNECTION_ODBC);
-	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
-	if (conn->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-	if (conn->cur_counter > 0)
-		return luaL_error (L, LUASQL_PREFIX"there are open cursors");
-
-	/* Decrement connection counter on environment object */
-	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
-	env = lua_touserdata (L, -1);
-	env->conn_counter--;
-	/* Nullify structure fields. */
-	conn->closed = 1;
-	luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
-	ret = SQLDisconnect(conn->hdbc);
-	if (error(ret))
-		return fail(L, hDBC, conn->hdbc);
-	ret = SQLFreeHandle(hDBC, conn->hdbc);
-	if (error(ret))
-		return fail(L, hDBC, conn->hdbc);
-    return pass(L);
-}
-
-
-/*
-** Executes a SQL statement.
-** Returns
-**   cursor object: if there are results or
-**   row count: number of rows affected by statement if no results
-*/
-static int conn_execute (lua_State *L) {
-	conn_data *conn = (conn_data *) getconnection (L);
-	const char *statement = luaL_checkstring(L, 2);
-	SQLHDBC hdbc = conn->hdbc;
-	SQLHSTMT hstmt;
-	SQLSMALLINT numcols;
-	SQLRETURN ret;
-	ret = SQLAllocHandle(hSTMT, hdbc, &hstmt);
-	if (error(ret))
-		return fail(L, hDBC, hdbc);
-
-	ret = SQLPrepare(hstmt, (char *) statement, SQL_NTS);
-	if (error(ret)) {
-		ret = fail(L, hSTMT, hstmt);
-		SQLFreeHandle(hSTMT, hstmt);
-		return ret;
-	}
-
-	/* execute the statement */
-	ret = SQLExecute (hstmt);
-	if (error(ret)) {
-		ret = fail(L, hSTMT, hstmt);
-		SQLFreeHandle(hSTMT, hstmt);
-		return ret;
-	}
-
-	/* determine the number of results */
-	ret = SQLNumResultCols (hstmt, &numcols);
-	if (error(ret)) {
-		ret = fail(L, hSTMT, hstmt);
-		SQLFreeHandle(hSTMT, hstmt);
-		return ret;
-	}
-
-	if (numcols > 0)
-    	/* if there is a results table (e.g., SELECT) */
-		return create_cursor (L, 1, conn, hstmt, numcols);
-	else {
-		/* if action has no results (e.g., UPDATE) */
-		SQLINTEGER numrows;
-		ret = SQLRowCount(hstmt, &numrows);
-		if (error(ret)) {
-			ret = fail(L, hSTMT, hstmt);
-			SQLFreeHandle(hSTMT, hstmt);
-			return ret;
-		}
-		lua_pushnumber(L, numrows);
-		SQLFreeHandle(hSTMT, hstmt);
-		return 1;
-	}
-}
-
-/*
-** Rolls back a transaction. 
-*/
-static int conn_commit (lua_State *L) {
-	conn_data *conn = (conn_data *) getconnection (L);
-	SQLRETURN ret = SQLEndTran(hDBC, conn->hdbc, SQL_COMMIT);
-	if (error(ret))
-		return fail(L, hSTMT, conn->hdbc);
-	else
-		return pass(L);
-}
-
-/*
-** Rollback the current transaction. 
-*/
-static int conn_rollback (lua_State *L) {
-	conn_data *conn = (conn_data *) getconnection (L);
-	SQLRETURN ret = SQLEndTran(hDBC, conn->hdbc, SQL_ROLLBACK);
-	if (error(ret))
-		return fail(L, hSTMT, conn->hdbc);
-	else
-		return pass(L);
-}
-
-/*
-** Sets the auto commit mode
-*/
-static int conn_setautocommit (lua_State *L) {
-	conn_data *conn = (conn_data *) getconnection (L);
-	SQLRETURN ret;
-	if (lua_toboolean (L, 2)) {
-		ret = SQLSetConnectAttr(conn->hdbc, SQL_ATTR_AUTOCOMMIT,
-			(SQLPOINTER) SQL_AUTOCOMMIT_ON, 0);
-	} else {
-		ret = SQLSetConnectAttr(conn->hdbc, SQL_ATTR_AUTOCOMMIT,
-			(SQLPOINTER) SQL_AUTOCOMMIT_OFF, 0);
-	}
-	if (error(ret))
-		return fail(L, hSTMT, conn->hdbc);
-	else
-		return pass(L);
-}
-
-
-/*
-** Create a new Connection object and push it on top of the stack.
-*/
-static int create_connection (lua_State *L, int o, env_data *env, SQLHDBC hdbc) {
-	conn_data *conn = (conn_data *) lua_newuserdata(L, sizeof(conn_data));
-	/* set auto commit mode */
-	SQLRETURN ret = SQLSetConnectAttr(hdbc, SQL_ATTR_AUTOCOMMIT, 
-		(SQLPOINTER) SQL_AUTOCOMMIT_ON, 0);
-	if (error(ret))
-		return fail(L, hDBC, hdbc);
-
-	luasql_setmeta (L, LUASQL_CONNECTION_ODBC);
-
-	/* fill in structure */
-	conn->closed = 0;
-	conn->cur_counter = 0;
-	conn->env = LUA_NOREF;
-	conn->hdbc = hdbc;
-	lua_pushvalue (L, o);
-	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
-	env->conn_counter++;
-	return 1;
-}
-
-
-/*
-** Creates and returns a connection object
-** Lua Input: source [, user [, pass]]
-**   source: data source
-**   user, pass: data source authentication information
-** Lua Returns:
-**   connection object if successfull
-**   nil and error message otherwise.
-*/
-static int env_connect (lua_State *L) {
-	env_data *env = (env_data *) getenvironment (L);
-	const char *sourcename = luaL_checkstring (L, 2);
-	const char *username = luaL_optstring (L, 3, NULL);
-	const char *password = luaL_optstring (L, 4, NULL);
-	SQLHDBC hdbc;
-	SQLRETURN ret;
-
-	/* tries to allocate connection handle */
-	ret = SQLAllocHandle (hDBC, env->henv, &hdbc);
-	if (error(ret))
-		return luasql_faildirect (L, LUASQL_PREFIX"connection allocation error.");
-
-	/* tries to connect handle */
-	ret = SQLConnect (hdbc, (char *) sourcename, SQL_NTS, 
-		(char *) username, SQL_NTS, (char *) password, SQL_NTS);
-	if (error(ret)) {
-		ret = fail(L, hDBC, hdbc);
-		SQLFreeHandle(hDBC, hdbc);
-		return ret;
-	}
-
-	/* success, return connection object */
-	return create_connection (L, 1, env, hdbc);
-}
-
-/*
-** Closes an environment object
-*/
-static int env_close (lua_State *L) {
-	SQLRETURN ret;
-	env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_ODBC);
-	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
-	if (env->closed) {
-		lua_pushboolean (L, 0);
-		return 1;
-	}
-	if (env->conn_counter > 0)
-		return luaL_error (L, LUASQL_PREFIX"there are open connections");
-
-	env->closed = 1;
-	ret = SQLFreeHandle (hENV, env->henv);
-	if (error(ret)) {
-		int ret = fail(L, hENV, env->henv);
-		env->henv = NULL;
-		return ret;
-	}
-	return pass(L);
-}
-
-/*
-** Create metatables for each class of object.
-*/
-static void create_metatables (lua_State *L) {
-	struct luaL_reg environment_methods[] = {
-		{"__gc", env_close},
-		{"close", env_close},
-		{"connect", env_connect},
-		{NULL, NULL},
-	};
-	struct luaL_reg connection_methods[] = {
-		{"__gc", conn_close},
-		{"close", conn_close},
-		{"execute", conn_execute},
-		{"commit", conn_commit},
-		{"rollback", conn_rollback},
-		{"setautocommit", conn_setautocommit},
-		{NULL, NULL},
-	};
-	struct luaL_reg cursor_methods[] = {
-		{"__gc", cur_close},
-		{"close", cur_close},
-		{"fetch", cur_fetch},
-		{"getcoltypes", cur_coltypes},
-		{"getcolnames", cur_colnames},
-		{NULL, NULL},
-	};
-	luasql_createmeta (L, LUASQL_ENVIRONMENT_ODBC, environment_methods);
-	luasql_createmeta (L, LUASQL_CONNECTION_ODBC, connection_methods);
-	luasql_createmeta (L, LUASQL_CURSOR_ODBC, cursor_methods);
-	lua_pop (L, 3);
-}
-
-
-/*
-** Creates an Environment and returns it.
-*/
-static int create_environment (lua_State *L) {
-	env_data *env;
-	SQLHENV henv;
-	SQLRETURN ret = SQLAllocHandle(hENV, SQL_NULL_HANDLE, &henv);
-	if (error(ret))
-		return luasql_faildirect(L,LUASQL_PREFIX"error creating environment.");
-
-	ret = SQLSetEnvAttr (henv, SQL_ATTR_ODBC_VERSION, 
-		(void*)SQL_OV_ODBC3, 0);
-	if (error(ret)) {
-		ret = luasql_faildirect (L, LUASQL_PREFIX"error setting SQL version.");
-		SQLFreeHandle (hENV, henv);
-		return ret;
-  }
-
-	env = (env_data *)lua_newuserdata (L, sizeof (env_data));
-	luasql_setmeta (L, LUASQL_ENVIRONMENT_ODBC);
-	/* fill in structure */
-	env->closed = 0;
-	env->conn_counter = 0;
-	env->henv = henv;
-	return 1;
-}
-
-
-/*
-** Creates the metatables for the objects and registers the
-** driver open method.
-*/
-LUASQL_API int luaopen_luasql_odbc (lua_State *L) {
-	struct luaL_reg driver[] = {
-		{"odbc", create_environment},
-		{NULL, NULL},
-	};
-	create_metatables (L);
-	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
-	luasql_set_info (L);
-	return 1;
-} 
+/*
+** LuaSQL, ODBC driver
+** Authors: Pedro Rabinovitch, Roberto Ierusalimschy, Diego Nehab,
+** Tomas Guisasola
+** See Copyright Notice in license.html
+** $Id: ls_odbc.c,v 1.38 2008/05/04 02:46:17 tomas Exp $
+*/
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#if defined(_WIN32)
+#include <windows.h>
+#include <sqlext.h>
+#elif defined(INFORMIX)
+#include "infxcli.h"
+#elif defined(UNIXODBC)
+#include "sql.h"
+#include "sqltypes.h"
+#include "sqlext.h"
+#endif
+
+#include "lua.h"
+#include "lauxlib.h"
+#if ! defined (LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
+#include "compat-5.1.h"
+#endif
+
+
+#include "luasql.h"
+
+#define LUASQL_ENVIRONMENT_ODBC "ODBC environment"
+#define LUASQL_CONNECTION_ODBC "ODBC connection"
+#define LUASQL_CURSOR_ODBC "ODBC cursor"
+
+
+typedef struct {
+	short      closed;
+	int        conn_counter;
+	SQLHENV    henv;               /* environment handle */
+} env_data;
+
+
+typedef struct {
+	short      closed;
+	int        cur_counter;
+	int        env;                /* reference to environment */
+	SQLHDBC    hdbc;               /* database connection handle */
+	int		   auto_commit;        /* should each statment be commited */
+} conn_data;
+
+
+typedef struct {
+	short      closed;
+	int        conn;               /* reference to connection */
+	int        numcols;            /* number of columns */
+	int        coltypes, colnames; /* reference to column information tables */
+	SQLHSTMT   hstmt;              /* statement handle */
+	char	  *modestring;
+} cur_data;
+
+
+/* we are lazy */
+#define hENV SQL_HANDLE_ENV
+#define hSTMT SQL_HANDLE_STMT
+#define hDBC SQL_HANDLE_DBC
+#define error(a) ((a) != SQL_SUCCESS && (a) != SQL_SUCCESS_WITH_INFO) 
+
+
+LUASQL_API int luaopen_luasql_odbc (lua_State *L);
+
+/*
+** Check for valid environment.
+*/
+static env_data *getenvironment (lua_State *L) {
+	env_data *env = (env_data *)luaL_checkudata (L, 1, LUASQL_ENVIRONMENT_ODBC);
+	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	luaL_argcheck (L, !env->closed, 1, LUASQL_PREFIX"environment is closed");
+	return env;
+}
+
+
+/*
+** Check for valid connection.
+*/
+static conn_data *getconnection (lua_State *L) {
+	conn_data *conn = (conn_data *)luaL_checkudata (L, 1, LUASQL_CONNECTION_ODBC);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	luaL_argcheck (L, !conn->closed, 1, LUASQL_PREFIX"connection is closed");
+	return conn;
+}
+
+
+/*
+** Check for valid cursor.
+*/
+static cur_data *getcursor (lua_State *L) {
+	cur_data *cursor = (cur_data *)luaL_checkudata (L, 1, LUASQL_CURSOR_ODBC);
+	luaL_argcheck (L, cursor != NULL, 1, LUASQL_PREFIX"cursor expected");
+	luaL_argcheck (L, !cursor->closed, 1, LUASQL_PREFIX"cursor is closed");
+	return cursor;
+}
+
+
+/*
+** Pushes true and returns 1
+*/
+static int pass(lua_State *L) {
+    lua_pushboolean (L, 1);
+    return 1;
+}
+
+
+/*
+** Fails with error message from ODBC
+** Inputs: 
+**   type: type of handle used in operation
+**   handle: handle used in operation
+*/
+static int fail(lua_State *L,  const SQLSMALLINT type, const SQLHANDLE handle) {
+    SQLCHAR State[6];
+    SQLINTEGER NativeError;
+    SQLSMALLINT MsgSize, i;
+    SQLRETURN ret;
+    char Msg[SQL_MAX_MESSAGE_LENGTH];
+    luaL_Buffer b;
+    lua_pushnil(L);
+
+    luaL_buffinit(L, &b);
+    i = 1;
+    while (1) {
+        ret = SQLGetDiagRec(type, handle, i, State, &NativeError, Msg, 
+                sizeof(Msg), &MsgSize);
+        if (ret == SQL_NO_DATA) break;
+        luaL_addlstring(&b, Msg, MsgSize);
+        luaL_putchar(&b, '\n');
+        i++;
+    } 
+    luaL_pushresult(&b);
+    return 2;
+}
+
+/*
+** Returns the name of an equivalent lua type for a SQL type.
+*/
+static const char *sqltypetolua (const SQLSMALLINT type) {
+    switch (type) {
+        case SQL_UNKNOWN_TYPE: case SQL_CHAR: case SQL_VARCHAR: 
+        case SQL_TYPE_DATE: case SQL_TYPE_TIME: case SQL_TYPE_TIMESTAMP: 
+        case SQL_DATE: case SQL_INTERVAL: case SQL_TIMESTAMP: 
+        case SQL_LONGVARCHAR:
+            return "string";
+        case SQL_BIGINT: case SQL_TINYINT: case SQL_NUMERIC: 
+        case SQL_DECIMAL: case SQL_INTEGER: case SQL_SMALLINT: 
+        case SQL_FLOAT: case SQL_REAL: case SQL_DOUBLE:
+            return "number";
+        case SQL_BINARY: case SQL_VARBINARY: case SQL_LONGVARBINARY:
+            return "binary";	/* !!!!!! nao seria string? */
+        case SQL_BIT:
+            return "boolean";
+        default:
+            assert(0);
+            return NULL;
+    }
+}
+
+
+/*
+** Retrieves data from the i_th column in the current row
+** Input
+**   types: index in stack of column types table
+**   hstmt: statement handle
+**   i: column number
+** Returns:
+**   0 if successfull, non-zero otherwise;
+*/
+static int push_column(lua_State *L, int coltypes, const SQLHSTMT hstmt, 
+        SQLUSMALLINT i) {
+    const char *tname;
+    char type;
+    /* get column type from types table */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, coltypes);
+	lua_rawgeti (L, -1, i);	/* typename of the column */
+    tname = lua_tostring(L, -1);
+    if (!tname)
+		return luasql_faildirect(L, LUASQL_PREFIX"Invalid type in table.");
+    type = tname[1];
+    lua_pop(L, 2);	/* pops type name and coltypes table */
+
+    /* deal with data according to type */
+    switch (type) {
+        /* nUmber */
+        case 'u': { 
+			double num;
+			SQLINTEGER got;
+			SQLRETURN rc = SQLGetData(hstmt, i, SQL_C_DOUBLE, &num, 0, &got);
+			if (error(rc))
+				return fail(L, hSTMT, hstmt);
+			if (got == SQL_NULL_DATA)
+				lua_pushnil(L);
+			else
+				lua_pushnumber(L, num);
+			return 0;
+		}
+                  /* bOol */
+        case 'o': { 
+			char b;
+			SQLINTEGER got;
+			SQLRETURN rc = SQLGetData(hstmt, i, SQL_C_BIT, &b, 0, &got);
+			if (error(rc))
+				return fail(L, hSTMT, hstmt);
+			if (got == SQL_NULL_DATA)
+				lua_pushnil(L);
+			else
+				lua_pushboolean(L, b);
+			return 0;
+		}
+        /* sTring */
+        case 't': 
+        /* bInary */
+        case 'i': { 
+			SQLSMALLINT stype = (type == 't') ? SQL_C_CHAR : SQL_C_BINARY;
+			SQLINTEGER got;
+			char *buffer;
+			luaL_Buffer b;
+			SQLRETURN rc;
+			luaL_buffinit(L, &b);
+			buffer = luaL_prepbuffer(&b);
+			rc = SQLGetData(hstmt, i, stype, buffer, LUAL_BUFFERSIZE, &got);
+			if (got == SQL_NULL_DATA) {
+				lua_pushnil(L);
+				return 0;
+			}
+			/* concat intermediary chunks */
+			while (rc == SQL_SUCCESS_WITH_INFO) {
+				if (got >= LUAL_BUFFERSIZE || got == SQL_NO_TOTAL) {
+					got = LUAL_BUFFERSIZE;
+					/* get rid of null termination in string block */
+					if (stype == SQL_C_CHAR) got--;
+				}
+				luaL_addsize(&b, got);
+				buffer = luaL_prepbuffer(&b);
+				rc = SQLGetData(hstmt, i, stype, buffer, 
+					LUAL_BUFFERSIZE, &got);
+			}
+			/* concat last chunk */
+			if (rc == SQL_SUCCESS) {
+				if (got >= LUAL_BUFFERSIZE || got == SQL_NO_TOTAL) {
+					got = LUAL_BUFFERSIZE;
+					/* get rid of null termination in string block */
+					if (stype == SQL_C_CHAR) got--;
+				}
+				luaL_addsize(&b, got);
+			}
+			if (rc == SQL_ERROR) return fail(L, hSTMT, hstmt);
+			/* return everything we got */
+			luaL_pushresult(&b);
+			return 0;
+		}
+    }
+    return 0;
+}
+
+/*
+** Get another row of the given cursor.
+*/
+static int cur_fetch (lua_State *L) {
+    cur_data *cur = (cur_data *) getcursor (L);
+    SQLHSTMT hstmt = cur->hstmt;
+    int ret; 
+    SQLRETURN rc = SQLFetch(cur->hstmt); 
+    if (rc == SQL_NO_DATA) {
+        lua_pushnil(L);
+        return 1;
+    } else if (error(rc)) return fail(L, hSTMT, hstmt);
+
+	if (lua_istable (L, 2)) {
+		SQLUSMALLINT i;
+		const char *opts = luaL_optstring (L, 3, "n");
+		int num = strchr (opts, 'n') != NULL;
+		int alpha = strchr (opts, 'a') != NULL;
+		for (i = 1; i <= cur->numcols; i++) {
+			ret = push_column (L, cur->coltypes, hstmt, i);
+			if (ret)
+				return ret;
+			if (alpha) {
+				lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);
+				lua_rawgeti (L, -1, i); /* gets column name */
+				lua_pushvalue (L, -3); /* duplicates column value */
+				lua_rawset (L, 2); /* table[name] = value */
+				lua_pop (L, 1);	/* pops colnames table */
+			}
+			if (num)
+				lua_rawseti (L, 2, i);
+			else
+				lua_pop (L, 1); /* pops value */
+		}
+		lua_pushvalue (L, 2);
+		return 1;	/* return table */
+	}
+	else {
+		SQLUSMALLINT i;
+		luaL_checkstack (L, cur->numcols, LUASQL_PREFIX"too many columns");
+		for (i = 1; i <= cur->numcols; i++) {
+			ret = push_column (L, cur->coltypes, hstmt, i);
+			if (ret)
+				return ret;
+		}
+		return cur->numcols;
+	}
+}
+
+/*
+** Closes a cursor.
+*/
+static int cur_close (lua_State *L) {
+	conn_data *conn;
+	cur_data *cur = (cur_data *) luaL_checkudata (L, 1, LUASQL_CURSOR_ODBC);
+	SQLRETURN ret;
+	luaL_argcheck (L, cur != NULL, 1, LUASQL_PREFIX"cursor expected");
+	if (cur->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+
+	/* Nullify structure fields. */
+	cur->closed = 1;
+	ret = SQLCloseCursor(cur->hstmt);
+    if (error(ret))
+		return fail(L, hSTMT, cur->hstmt);
+	ret = SQLFreeHandle(hSTMT, cur->hstmt);
+	if (error(ret))
+		return fail(L, hSTMT, cur->hstmt);
+	/* Decrement cursor counter on connection object */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->conn);
+	conn = lua_touserdata (L, -1);
+	conn->cur_counter--;
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->conn);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->colnames);
+	luaL_unref (L, LUA_REGISTRYINDEX, cur->coltypes);
+    return pass(L);
+}
+
+
+/*
+** Returns the table with column names.
+*/
+static int cur_colnames (lua_State *L) {
+	cur_data *cur = (cur_data *) getcursor (L);
+	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->colnames);
+	return 1;
+}
+
+
+/*
+** Returns the table with column types.
+*/
+static int cur_coltypes (lua_State *L) {
+	cur_data *cur = (cur_data *) getcursor (L);
+	lua_rawgeti (L, LUA_REGISTRYINDEX, cur->coltypes);
+	return 1;
+}
+
+
+/*
+ * Sets the cursor parameters
+ */
+static void cur_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					if( lua_isstring( L, -1 ) )
+						cur->modestring = lua_tostring( L, -1 );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified cursor parameters
+ */
+static int cur_get( lua_State *L ) {
+	if( lua_istable( L, 2 ) ) {
+		lua_newtable(L);
+		int rsp = lua_gettop(L);
+		cur_data *cur = getcursor(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+					lua_pushstring( L, LUASQL_MODESTRING );
+					lua_pushstring( L, cur->modestring );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_MODESTRING) == 0 ) {
+				cur_data *cur = getcursor(L);
+				lua_pushstring( L, cur->modestring );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Creates two tables with the names and the types of the columns.
+*/
+static void create_colinfo (lua_State *L, cur_data *cur) {
+	SQLCHAR buffer[256];
+	SQLSMALLINT namelen, datatype, i;
+	SQLRETURN ret;
+	int types, names;
+
+	lua_newtable(L);
+	types = lua_gettop (L);
+	lua_newtable(L);
+	names = lua_gettop (L);
+	for (i = 1; i <= cur->numcols; i++) {
+		ret = SQLDescribeCol(cur->hstmt, i, buffer, sizeof(buffer), 
+                &namelen, &datatype, NULL, NULL, NULL);
+		/*if (ret == SQL_ERROR) return fail(L, hSTMT, cur->hstmt);*/
+		lua_pushstring (L, buffer);
+		lua_rawseti (L, names, i);
+		lua_pushstring(L, sqltypetolua(datatype));
+		lua_rawseti (L, types, i);
+	}
+	cur->colnames = luaL_ref (L, LUA_REGISTRYINDEX);
+	cur->coltypes = luaL_ref (L, LUA_REGISTRYINDEX);
+}
+
+
+/*
+** Creates a cursor table and leave it on the top of the stack.
+*/
+static int create_cursor (lua_State *L, int o, conn_data *conn, 
+        const SQLHSTMT hstmt, const SQLSMALLINT numcols) {
+    cur_data *cur = (cur_data *) lua_newuserdata(L, sizeof(cur_data));
+	luasql_setmeta (L, LUASQL_CURSOR_ODBC);
+
+	conn->cur_counter++;
+    /* fill in structure */
+	cur->closed = 0;
+	cur->conn = LUA_NOREF;
+    cur->numcols = numcols;
+	cur->colnames = LUA_NOREF;
+	cur->coltypes = LUA_NOREF;
+    cur->hstmt = hstmt;
+	cur->modestring = "n";
+	lua_pushvalue (L, o);
+    cur->conn = luaL_ref (L, LUA_REGISTRYINDEX);
+
+	/* make and store column information table */
+	create_colinfo (L, cur);
+
+    return 1;
+}
+
+
+/*
+** Closes a connection.
+*/
+static int conn_close (lua_State *L) {
+	SQLRETURN ret;
+	env_data *env;
+    conn_data *conn = (conn_data *)luaL_checkudata(L,1,LUASQL_CONNECTION_ODBC);
+	luaL_argcheck (L, conn != NULL, 1, LUASQL_PREFIX"connection expected");
+	if (conn->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+	if (conn->cur_counter > 0)
+		return luaL_error (L, LUASQL_PREFIX"there are open cursors");
+
+	/* Decrement connection counter on environment object */
+	lua_rawgeti (L, LUA_REGISTRYINDEX, conn->env);
+	env = lua_touserdata (L, -1);
+	env->conn_counter--;
+	/* Nullify structure fields. */
+	conn->closed = 1;
+	luaL_unref (L, LUA_REGISTRYINDEX, conn->env);
+	ret = SQLDisconnect(conn->hdbc);
+	if (error(ret))
+		return fail(L, hDBC, conn->hdbc);
+	ret = SQLFreeHandle(hDBC, conn->hdbc);
+	if (error(ret))
+		return fail(L, hDBC, conn->hdbc);
+    return pass(L);
+}
+
+
+/*
+** Executes a SQL statement.
+** Returns
+**   cursor object: if there are results or
+**   row count: number of rows affected by statement if no results
+*/
+static int conn_execute (lua_State *L) {
+	conn_data *conn = (conn_data *) getconnection (L);
+	const char *statement = luaL_checkstring(L, 2);
+	SQLHDBC hdbc = conn->hdbc;
+	SQLHSTMT hstmt;
+	SQLSMALLINT numcols;
+	SQLRETURN ret;
+	ret = SQLAllocHandle(hSTMT, hdbc, &hstmt);
+	if (error(ret))
+		return fail(L, hDBC, hdbc);
+
+	ret = SQLPrepare(hstmt, (char *) statement, SQL_NTS);
+	if (error(ret)) {
+		ret = fail(L, hSTMT, hstmt);
+		SQLFreeHandle(hSTMT, hstmt);
+		return ret;
+	}
+
+	/* execute the statement */
+	ret = SQLExecute (hstmt);
+	if (error(ret)) {
+		ret = fail(L, hSTMT, hstmt);
+		SQLFreeHandle(hSTMT, hstmt);
+		return ret;
+	}
+
+	/* determine the number of results */
+	ret = SQLNumResultCols (hstmt, &numcols);
+	if (error(ret)) {
+		ret = fail(L, hSTMT, hstmt);
+		SQLFreeHandle(hSTMT, hstmt);
+		return ret;
+	}
+
+	if (numcols > 0)
+    	/* if there is a results table (e.g., SELECT) */
+		return create_cursor (L, 1, conn, hstmt, numcols);
+	else {
+		/* if action has no results (e.g., UPDATE) */
+		SQLINTEGER numrows;
+		ret = SQLRowCount(hstmt, &numrows);
+		if (error(ret)) {
+			ret = fail(L, hSTMT, hstmt);
+			SQLFreeHandle(hSTMT, hstmt);
+			return ret;
+		}
+		lua_pushnumber(L, numrows);
+		SQLFreeHandle(hSTMT, hstmt);
+		return 1;
+	}
+}
+
+/*
+** Rolls back a transaction. 
+*/
+static int conn_commit (lua_State *L) {
+	conn_data *conn = (conn_data *) getconnection (L);
+	SQLRETURN ret = SQLEndTran(hDBC, conn->hdbc, SQL_COMMIT);
+	if (error(ret))
+		return fail(L, hSTMT, conn->hdbc);
+	else
+		return pass(L);
+}
+
+/*
+** Rollback the current transaction. 
+*/
+static int conn_rollback (lua_State *L) {
+	conn_data *conn = (conn_data *) getconnection (L);
+	SQLRETURN ret = SQLEndTran(hDBC, conn->hdbc, SQL_ROLLBACK);
+	if (error(ret))
+		return fail(L, hSTMT, conn->hdbc);
+	else
+		return pass(L);
+}
+
+/*
+** Sets the auto commit mode
+*/
+static int conn_dosetautocommit(lua_State *L, conn_data *conn, int pos){
+	SQLRETURN ret;
+	if (lua_toboolean (L, pos)) {
+		ret = SQLSetConnectAttr(conn->hdbc, SQL_ATTR_AUTOCOMMIT,
+			(SQLPOINTER) SQL_AUTOCOMMIT_ON, 0);
+	} else {
+		ret = SQLSetConnectAttr(conn->hdbc, SQL_ATTR_AUTOCOMMIT,
+			(SQLPOINTER) SQL_AUTOCOMMIT_OFF, 0);
+	}
+	if (error(ret))
+		return fail(L, hSTMT, conn->hdbc);
+	else
+		return pass(L);
+}
+
+static int conn_setautocommit (lua_State *L) {
+	conn_data *conn = (conn_data *) getconnection (L);
+	return conn_dosetautocommit(L, conn, 2); 
+}
+
+
+/*
+ * Sets the connection parameters
+ */
+static void conn_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					if( lua_isboolean( L, -1 ) )
+						conn_dosetautocommit(L, conn, -1);
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+
+/*
+ * Retrieve the specified connection parameters
+ */
+static int conn_get( lua_State *L ) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		conn_data *conn = getconnection(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+
+				if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+					lua_pushstring( L, LUASQL_AUTOCOMMIT );
+					lua_pushboolean( L, conn->auto_commit );
+					lua_settable( L, rsp );
+				}
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+
+			if( strcmp(key, LUASQL_AUTOCOMMIT) == 0 ) {
+				conn_data *conn = getconnection(L);
+				lua_pushboolean( L, conn->auto_commit );
+			} else
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create a new Connection object and push it on top of the stack.
+*/
+static int create_connection (lua_State *L, int o, env_data *env, SQLHDBC hdbc) {
+	conn_data *conn = (conn_data *) lua_newuserdata(L, sizeof(conn_data));
+	/* set auto commit mode */
+	SQLRETURN ret = SQLSetConnectAttr(hdbc, SQL_ATTR_AUTOCOMMIT, 
+		(SQLPOINTER) SQL_AUTOCOMMIT_ON, 0);
+	if (error(ret))
+		return fail(L, hDBC, hdbc);
+
+	luasql_setmeta (L, LUASQL_CONNECTION_ODBC);
+
+	/* fill in structure */
+	conn->closed = 0;
+	conn->cur_counter = 0;
+	conn->env = LUA_NOREF;
+	conn->hdbc = hdbc;
+	conn->auto_commit = 1;
+	lua_pushvalue (L, o);
+	conn->env = luaL_ref (L, LUA_REGISTRYINDEX);
+	env->conn_counter++;
+	return 1;
+}
+
+
+/*
+** Creates and returns a connection object
+** Lua Input: source [, user [, pass]]
+**   source: data source
+**   user, pass: data source authentication information
+** Lua Returns:
+**   connection object if successfull
+**   nil and error message otherwise.
+*/
+static int env_connect (lua_State *L) {
+	env_data *env = (env_data *) getenvironment (L);
+	char *sourcename = NULL;
+	char *username = NULL;
+	char *password = NULL;
+	SQLHDBC hdbc;
+	SQLRETURN ret;
+
+	if( lua_istable( L, 2 ) ) {
+		lua_pushstring( L, LUASQL_SOURCENAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			sourcename = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );		
+		lua_pushstring( L, LUASQL_USERNAME );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			username = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+		lua_pushstring( L, LUASQL_PASSWORD );
+		lua_gettable( L, 2 );
+		
+		if( lua_isstring( L, -1 ) )
+			password = lua_tostring( L, -1 );
+
+		lua_pop( L, 1 );
+	} else {
+		sourcename = luaL_checkstring (L, 2);
+		username = luaL_optstring (L, 3, NULL);
+		password = luaL_optstring (L, 4, NULL);
+	}
+
+	/* tries to allocate connection handle */
+	ret = SQLAllocHandle (hDBC, env->henv, &hdbc);
+	if (error(ret))
+		return luasql_faildirect (L, LUASQL_PREFIX"connection allocation error.");
+
+	/* tries to connect handle */
+	ret = SQLConnect (hdbc, (char *) sourcename, SQL_NTS, 
+		(char *) username, SQL_NTS, (char *) password, SQL_NTS);
+	if (error(ret)) {
+		ret = fail(L, hDBC, hdbc);
+		SQLFreeHandle(hDBC, hdbc);
+		return ret;
+	}
+
+	/* success, return connection object */
+	return create_connection (L, 1, env, hdbc);
+}
+
+/*
+** Closes an environment object
+*/
+static int env_close (lua_State *L) {
+	SQLRETURN ret;
+	env_data *env = (env_data *)luaL_checkudata(L, 1, LUASQL_ENVIRONMENT_ODBC);
+	luaL_argcheck (L, env != NULL, 1, LUASQL_PREFIX"environment expected");
+	if (env->closed) {
+		lua_pushboolean (L, 0);
+		return 1;
+	}
+	if (env->conn_counter > 0)
+		return luaL_error (L, LUASQL_PREFIX"there are open connections");
+
+	env->closed = 1;
+	ret = SQLFreeHandle (hENV, env->henv);
+	if (error(ret)) {
+		int ret = fail(L, hENV, env->henv);
+		env->henv = NULL;
+		return ret;
+	}
+	return pass(L);
+}
+
+/*
+ * Sets the environment parameters
+ */
+static void env_set(lua_State *L) {
+	if( lua_istable( L, 2 ) ) {
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -2) ) {
+				key = lua_tostring(L, -2);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					if( lua_isnumber( L, -1 ) )
+						env->locktimeout = lua_tointeger( L, -1 );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	}
+}
+
+/*
+ * Retrieve the specified environment parameters
+ */
+static int env_get(lua_State *L) {
+	lua_newtable(L);
+
+	if( lua_istable( L, 2 ) ) {
+		int rsp = lua_gettop(L);
+		env_data *env = getenvironment(L);
+		char *key;
+		lua_pushnil(L);
+
+		while( lua_next(L, 2) != 0 ) {
+			if( lua_isstring(L, -1) ) {
+				key = lua_tostring(L, -1);
+/*
+				if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+					lua_pushstring( L, LUASQL_LOCKTIMEOUT );
+					lua_pushinteger( L, env->locktimeout );
+					lua_settable( L, rsp );
+				} */
+			}
+
+			lua_pop(L, 1);
+		}		
+	} else
+		if( lua_isstring( L, 2 ) ) {
+			const char *key = lua_tostring(L, 2);
+/*
+			if( strcmp(key, LUASQL_LOCKTIMEOUT) == 0 ) {
+				env_data *env = getenvironment(L);
+				lua_pushinteger( L, env->locktimeout );
+			} else  */
+				lua_pushnil(L);
+		} else 
+			lua_pushnil(L);
+
+	return 1;
+}
+
+
+/*
+** Create metatables for each class of object.
+*/
+static void create_metatables (lua_State *L) {
+	struct luaL_reg environment_methods[] = {
+		{"__gc", env_close},
+		{"close", env_close},
+		{"connect", env_connect},
+	    {"get", env_get},
+	    {"set", env_set},
+		{NULL, NULL},
+	};
+	struct luaL_reg connection_methods[] = {
+		{"__gc", conn_close},
+		{"close", conn_close},
+		{"execute", conn_execute},
+		{"commit", conn_commit},
+		{"rollback", conn_rollback},
+		{"setautocommit", conn_setautocommit},
+	    {"get", conn_get},
+	    {"set", conn_set},
+		{NULL, NULL},
+	};
+	struct luaL_reg cursor_methods[] = {
+		{"__gc", cur_close},
+		{"close", cur_close},
+		{"fetch", cur_fetch},
+		{"getcoltypes", cur_coltypes},
+		{"getcolnames", cur_colnames},
+	    {"get", cur_get},
+	    {"set", cur_set},
+		{NULL, NULL},
+	};
+	luasql_createmeta (L, LUASQL_ENVIRONMENT_ODBC, environment_methods);
+	luasql_createmeta (L, LUASQL_CONNECTION_ODBC, connection_methods);
+	luasql_createmeta (L, LUASQL_CURSOR_ODBC, cursor_methods);
+	lua_pop (L, 3);
+}
+
+
+/*
+** Creates an Environment and returns it.
+*/
+static int create_environment (lua_State *L) {
+	env_data *env;
+	SQLHENV henv;
+	SQLRETURN ret = SQLAllocHandle(hENV, SQL_NULL_HANDLE, &henv);
+	if (error(ret))
+		return luasql_faildirect(L,LUASQL_PREFIX"error creating environment.");
+
+	ret = SQLSetEnvAttr (henv, SQL_ATTR_ODBC_VERSION, 
+		(void*)SQL_OV_ODBC3, 0);
+	if (error(ret)) {
+		ret = luasql_faildirect (L, LUASQL_PREFIX"error setting SQL version.");
+		SQLFreeHandle (hENV, henv);
+		return ret;
+  }
+
+	env = (env_data *)lua_newuserdata (L, sizeof (env_data));
+	luasql_setmeta (L, LUASQL_ENVIRONMENT_ODBC);
+	/* fill in structure */
+	env->closed = 0;
+	env->conn_counter = 0;
+	env->henv = henv;
+	return 1;
+}
+
+
+/*
+** Creates the metatables for the objects and registers the
+** driver open method.
+*/
+LUASQL_API int luaopen_luasql_odbc (lua_State *L) {
+	struct luaL_reg driver[] = {
+		{"odbc", create_environment},
+		{NULL, NULL},
+	};
+	create_metatables (L);
+	luaL_openlib (L, LUASQL_TABLENAME, driver, 0);
+	luasql_set_info (L);
+	return 1;
+} 
Index: src/luasql.h
===================================================================
RCS file: /cvsroot/luasql/luasql/src/luasql.h,v
retrieving revision 1.11
diff -u -r1.11 luasql.h
--- src/luasql.h	21 Mar 2007 23:12:57 -0000	1.11
+++ src/luasql.h	2 Aug 2008 00:31:39 -0000
@@ -1,28 +1,38 @@
-/*
-** $Id: luasql.h,v 1.11 2007/03/21 23:12:57 mascarenhas Exp $
-** See Copyright Notice in license.html
-*/
-
-#ifndef _LUASQL_
-#define _LUASQL_
-
-#ifndef LUASQL_API
-#define LUASQL_API
-#endif
-
-#define LUASQL_PREFIX "LuaSQL: "
-#define LUASQL_TABLENAME "luasql"
-#define LUASQL_ENVIRONMENT "Each driver must have an environment metatable"
-#define LUASQL_CONNECTION "Each driver must have a connection metatable"
-#define LUASQL_CURSOR "Each driver must have a cursor metatable"
-
-typedef struct {
-	short  closed;
-} pseudo_data;
-
-LUASQL_API int luasql_faildirect (lua_State *L, const char *err);
-LUASQL_API int luasql_createmeta (lua_State *L, const char *name, const luaL_reg *methods);
-LUASQL_API void luasql_setmeta (lua_State *L, const char *name);
-LUASQL_API void luasql_set_info (lua_State *L);
-
-#endif
+/*
+** $Id: luasql.h,v 1.11 2007/03/21 23:12:57 mascarenhas Exp $
+** See Copyright Notice in license.html
+*/
+
+#ifndef _LUASQL_
+#define _LUASQL_
+
+#ifndef LUASQL_API
+#define LUASQL_API
+#endif
+
+#define LUASQL_PREFIX		"LuaSQL: "
+#define LUASQL_TABLENAME	"luasql"
+#define LUASQL_ENVIRONMENT	"Each driver must have an environment metatable"
+#define LUASQL_CONNECTION	"Each driver must have a connection metatable"
+#define LUASQL_CURSOR		"Each driver must have a cursor metatable"
+
+#define LUASQL_SOURCENAME	"sourcename"
+#define LUASQL_USERNAME		"username"
+#define LUASQL_PASSWORD		"password"
+#define LUASQL_HOSTNAME		"hostname"
+#define LUASQL_PORT			"port"
+#define LUASQL_AUTOCOMMIT	"autocommit"
+#define LUASQL_MODESTRING	"modestring"
+
+typedef struct {
+	short  closed;
+} pseudo_data;
+
+LUASQL_API int luasql_faildirect (lua_State *L, const char *err);
+LUASQL_API int luasql_createmeta (lua_State *L,const char *name, const luaL_reg *methods);
+LUASQL_API void luasql_setmeta (lua_State *L, const char *name);
+LUASQL_API void luasql_set_info (lua_State *L);
+
+LUASQL_API char* luasql_getfetchmodestring( lua_State *L, const char *msdefault );
+
+#endif
